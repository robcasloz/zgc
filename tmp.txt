8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000    1) /*
cf3e4bfdb5b5 src/hotspot/share/opto/output.cpp    (Harold Seigel       2021-01-11 18:18:13 +0000    2)  * Copyright (c) 1998, 2021, Oracle and/or its affiliates. All rights reserved.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000    3)  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000    4)  *
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000    5)  * This code is free software; you can redistribute it and/or modify it
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000    6)  * under the terms of the GNU General Public License version 2 only, as
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000    7)  * published by the Free Software Foundation.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000    8)  *
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000    9)  * This code is distributed in the hope that it will be useful, but WITHOUT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000   10)  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000   11)  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000   12)  * version 2 for more details (a copy is included in the LICENSE file that
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000   13)  * accompanied this code).
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000   14)  *
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000   15)  * You should have received a copy of the GNU General Public License version
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000   16)  * 2 along with this work; if not, write to the Free Software Foundation,
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000   17)  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000   18)  *
ba7c17365989 hotspot/src/share/vm/opto/output.cpp (Erik Trimble        2010-05-27 19:08:38 -0700   19)  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
ba7c17365989 hotspot/src/share/vm/opto/output.cpp (Erik Trimble        2010-05-27 19:08:38 -0700   20)  * or visit www.oracle.com if you need additional information or have any
ba7c17365989 hotspot/src/share/vm/opto/output.cpp (Erik Trimble        2010-05-27 19:08:38 -0700   21)  * questions.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000   22)  *
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000   23)  */
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000   24) 
8006fe8f753c hotspot/src/share/vm/opto/output.cpp (Stefan Karlsson     2010-11-23 13:22:55 -0800   25) #include "precompiled.hpp"
8006fe8f753c hotspot/src/share/vm/opto/output.cpp (Stefan Karlsson     2010-11-23 13:22:55 -0800   26) #include "asm/assembler.inline.hpp"
221d0f4c54b6 src/hotspot/share/opto/output.cpp    (Coleen Phillimore   2018-03-21 19:45:24 -0400   27) #include "asm/macroAssembler.inline.hpp"
3f42e9e11835 hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2013-04-24 20:55:28 -0400   28) #include "code/compiledIC.hpp"
8006fe8f753c hotspot/src/share/vm/opto/output.cpp (Stefan Karlsson     2010-11-23 13:22:55 -0800   29) #include "code/debugInfo.hpp"
8006fe8f753c hotspot/src/share/vm/opto/output.cpp (Stefan Karlsson     2010-11-23 13:22:55 -0800   30) #include "code/debugInfoRec.hpp"
8006fe8f753c hotspot/src/share/vm/opto/output.cpp (Stefan Karlsson     2010-11-23 13:22:55 -0800   31) #include "compiler/compileBroker.hpp"
5a5faf94bf1f hotspot/src/share/vm/opto/output.cpp (Nils Eliasson       2015-10-20 18:07:28 +0200   32) #include "compiler/compilerDirectives.hpp"
241f401815db src/hotspot/share/opto/output.cpp    (Vladimir Kozlov     2020-06-12 14:33:20 -0700   33) #include "compiler/disassembler.hpp"
8006fe8f753c hotspot/src/share/vm/opto/output.cpp (Stefan Karlsson     2010-11-23 13:22:55 -0800   34) #include "compiler/oopMap.hpp"
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000   35) #include "gc/shared/barrierSet.hpp"
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000   36) #include "gc/shared/c2/barrierSetC2.hpp"
8006fe8f753c hotspot/src/share/vm/opto/output.cpp (Stefan Karlsson     2010-11-23 13:22:55 -0800   37) #include "memory/allocation.inline.hpp"
0fb31dbf3a2a src/hotspot/share/opto/output.cpp    (Maurizio Cimadamore 2020-11-23 11:00:38 +0000   38) #include "memory/allocation.hpp"
25f33c005ddd hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2014-07-04 11:46:01 +0200   39) #include "opto/ad.hpp"
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   40) #include "opto/block.hpp"
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   41) #include "opto/c2compiler.hpp"
8006fe8f753c hotspot/src/share/vm/opto/output.cpp (Stefan Karlsson     2010-11-23 13:22:55 -0800   42) #include "opto/callnode.hpp"
8006fe8f753c hotspot/src/share/vm/opto/output.cpp (Stefan Karlsson     2010-11-23 13:22:55 -0800   43) #include "opto/cfgnode.hpp"
8006fe8f753c hotspot/src/share/vm/opto/output.cpp (Stefan Karlsson     2010-11-23 13:22:55 -0800   44) #include "opto/locknode.hpp"
8006fe8f753c hotspot/src/share/vm/opto/output.cpp (Stefan Karlsson     2010-11-23 13:22:55 -0800   45) #include "opto/machnode.hpp"
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   46) #include "opto/node.hpp"
25f33c005ddd hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2014-07-04 11:46:01 +0200   47) #include "opto/optoreg.hpp"
8006fe8f753c hotspot/src/share/vm/opto/output.cpp (Stefan Karlsson     2010-11-23 13:22:55 -0800   48) #include "opto/output.hpp"
8006fe8f753c hotspot/src/share/vm/opto/output.cpp (Stefan Karlsson     2010-11-23 13:22:55 -0800   49) #include "opto/regalloc.hpp"
8006fe8f753c hotspot/src/share/vm/opto/output.cpp (Stefan Karlsson     2010-11-23 13:22:55 -0800   50) #include "opto/runtime.hpp"
8006fe8f753c hotspot/src/share/vm/opto/output.cpp (Stefan Karlsson     2010-11-23 13:22:55 -0800   51) #include "opto/subnode.hpp"
8006fe8f753c hotspot/src/share/vm/opto/output.cpp (Stefan Karlsson     2010-11-23 13:22:55 -0800   52) #include "opto/type.hpp"
8006fe8f753c hotspot/src/share/vm/opto/output.cpp (Stefan Karlsson     2010-11-23 13:22:55 -0800   53) #include "runtime/handles.inline.hpp"
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   54) #include "runtime/sharedRuntime.hpp"
ccdde4972871 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-02-24 14:37:30 +0000   55) #include "utilities/macros.hpp"
e4b27a48a028 src/hotspot/share/opto/output.cpp    (Stefan Karlsson     2020-02-17 10:03:17 +0100   56) #include "utilities/powerOfTwo.hpp"
8006fe8f753c hotspot/src/share/vm/opto/output.cpp (Stefan Karlsson     2010-11-23 13:22:55 -0800   57) #include "utilities/xmlstream.hpp"
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000   58) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000   59) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000   60) #define DEBUG_ARG(x) , x
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000   61) #else
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000   62) #define DEBUG_ARG(x)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000   63) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000   64) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   65) //------------------------------Scheduling----------------------------------
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   66) // This class contains all the information necessary to implement instruction
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   67) // scheduling and bundling.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   68) class Scheduling {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   69) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   70) private:
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   71)   // Arena to use
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   72)   Arena *_arena;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   73) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   74)   // Control-Flow Graph info
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   75)   PhaseCFG *_cfg;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   76) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   77)   // Register Allocation info
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   78)   PhaseRegAlloc *_regalloc;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   79) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   80)   // Number of nodes in the method
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   81)   uint _node_bundling_limit;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   82) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   83)   // List of scheduled nodes. Generated in reverse order
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   84)   Node_List _scheduled;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   85) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   86)   // List of nodes currently available for choosing for scheduling
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   87)   Node_List _available;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   88) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   89)   // For each instruction beginning a bundle, the number of following
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   90)   // nodes to be bundled with it.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   91)   Bundle *_node_bundling_base;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   92) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   93)   // Mapping from register to Node
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   94)   Node_List _reg_node;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   95) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   96)   // Free list for pinch nodes.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   97)   Node_List _pinch_free_list;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   98) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000   99)   // Latency from the beginning of the containing basic block (base 1)
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  100)   // for each node.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  101)   unsigned short *_node_latency;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  102) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  103)   // Number of uses of this node within the containing basic block.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  104)   short *_uses;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  105) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  106)   // Schedulable portion of current block.  Skips Region/Phi/CreateEx up
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  107)   // front, branch+proj at end.  Also skips Catch/CProj (same as
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  108)   // branch-at-end), plus just-prior exception-throwing call.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  109)   uint _bb_start, _bb_end;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  110) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  111)   // Latency from the end of the basic block as scheduled
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  112)   unsigned short *_current_latency;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  113) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  114)   // Remember the next node
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  115)   Node *_next_node;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  116) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  117)   // Use this for an unconditional branch delay slot
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  118)   Node *_unconditional_delay_slot;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  119) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  120)   // Pointer to a Nop
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  121)   MachNopNode *_nop;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  122) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  123)   // Length of the current bundle, in instructions
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  124)   uint _bundle_instr_count;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  125) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  126)   // Current Cycle number, for computing latencies and bundling
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  127)   uint _bundle_cycle_number;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  128) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  129)   // Bundle information
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  130)   Pipeline_Use_Element _bundle_use_elements[resource_count];
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  131)   Pipeline_Use         _bundle_use;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  132) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  133)   // Dump the available list
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  134)   void dump_available() const;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  135) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  136) public:
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  137)   Scheduling(Arena *arena, Compile &compile);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  138) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  139)   // Destructor
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  140)   NOT_PRODUCT( ~Scheduling(); )
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  141) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  142)   // Step ahead "i" cycles
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  143)   void step(uint i);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  144) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  145)   // Step ahead 1 cycle, and clear the bundle state (for example,
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  146)   // at a branch target)
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  147)   void step_and_clear();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  148) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  149)   Bundle* node_bundling(const Node *n) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  150)     assert(valid_bundle_info(n), "oob");
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  151)     return (&_node_bundling_base[n->_idx]);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  152)   }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  153) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  154)   bool valid_bundle_info(const Node *n) const {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  155)     return (_node_bundling_limit > n->_idx);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  156)   }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  157) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  158)   bool starts_bundle(const Node *n) const {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  159)     return (_node_bundling_limit > n->_idx && _node_bundling_base[n->_idx].starts_bundle());
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  160)   }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  161) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  162)   // Do the scheduling
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  163)   void DoScheduling();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  164) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  165)   // Compute the local latencies walking forward over the list of
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  166)   // nodes for a basic block
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  167)   void ComputeLocalLatenciesForward(const Block *bb);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  168) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  169)   // Compute the register antidependencies within a basic block
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  170)   void ComputeRegisterAntidependencies(Block *bb);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  171)   void verify_do_def( Node *n, OptoReg::Name def, const char *msg );
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  172)   void verify_good_schedule( Block *b, const char *msg );
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  173)   void anti_do_def( Block *b, Node *def, OptoReg::Name def_reg, int is_def );
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  174)   void anti_do_use( Block *b, Node *use, OptoReg::Name use_reg );
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  175) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  176)   // Add a node to the current bundle
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  177)   void AddNodeToBundle(Node *n, const Block *bb);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  178) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  179)   // Add a node to the list of available nodes
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  180)   void AddNodeToAvailableList(Node *n);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  181) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  182)   // Compute the local use count for the nodes in a block, and compute
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  183)   // the list of instructions with no uses in the block as available
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  184)   void ComputeUseCount(const Block *bb);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  185) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  186)   // Choose an instruction from the available list to add to the bundle
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  187)   Node * ChooseNodeToBundle();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  188) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  189)   // See if this Node fits into the currently accumulating bundle
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  190)   bool NodeFitsInBundle(Node *n);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  191) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  192)   // Decrement the use count for a node
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  193)  void DecrementUseCounts(Node *n, const Block *bb);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  194) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  195)   // Garbage collect pinch nodes for reuse by other blocks.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  196)   void garbage_collect_pinch_nodes();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  197)   // Clean up a pinch node for reuse (helper for above).
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  198)   void cleanup_pinch( Node *pinch );
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  199) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  200)   // Information for statistics gathering
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  201) #ifndef PRODUCT
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  202) private:
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  203)   // Gather information on size of nops relative to total
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  204)   uint _branches, _unconditional_delays;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  205) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  206)   static uint _total_nop_size, _total_method_size;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  207)   static uint _total_branches, _total_unconditional_delays;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  208)   static uint _total_instructions_per_bundle[Pipeline::_max_instrs_per_cycle+1];
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  209) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  210) public:
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  211)   static void print_statistics();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  212) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  213)   static void increment_instructions_per_bundle(uint i) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  214)     _total_instructions_per_bundle[i]++;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  215)   }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  216) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  217)   static void increment_nop_size(uint s) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  218)     _total_nop_size += s;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  219)   }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  220) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  221)   static void increment_method_size(uint s) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  222)     _total_method_size += s;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  223)   }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  224) #endif
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  225) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  226) };
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  227) 
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  228) volatile int C2SafepointPollStubTable::_stub_size = 0;
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  229) 
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  230) Label& C2SafepointPollStubTable::add_safepoint(uintptr_t safepoint_offset) {
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  231)   C2SafepointPollStub* entry = new (Compile::current()->comp_arena()) C2SafepointPollStub(safepoint_offset);
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  232)   _safepoints.append(entry);
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  233)   return entry->_stub_label;
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  234) }
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  235) 
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  236) void C2SafepointPollStubTable::emit(CodeBuffer& cb) {
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  237)   MacroAssembler masm(&cb);
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  238)   for (int i = _safepoints.length() - 1; i >= 0; i--) {
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  239)     // Make sure there is enough space in the code buffer
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  240)     if (cb.insts()->maybe_expand_to_ensure_remaining(PhaseOutput::MAX_inst_size) && cb.blob() == NULL) {
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  241)       ciEnv::current()->record_failure("CodeCache is full");
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  242)       return;
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  243)     }
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  244) 
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  245)     C2SafepointPollStub* entry = _safepoints.at(i);
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  246)     emit_stub(masm, entry);
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  247)   }
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  248) }
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  249) 
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  250) int C2SafepointPollStubTable::stub_size_lazy() const {
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  251)   int size = Atomic::load(&_stub_size);
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  252) 
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  253)   if (size != 0) {
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  254)     return size;
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  255)   }
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  256) 
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  257)   Compile* const C = Compile::current();
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  258)   BufferBlob* const blob = C->output()->scratch_buffer_blob();
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  259)   CodeBuffer cb(blob->content_begin(), C->output()->scratch_buffer_code_size());
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  260)   MacroAssembler masm(&cb);
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  261)   C2SafepointPollStub* entry = _safepoints.at(0);
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  262)   emit_stub(masm, entry);
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  263)   size += cb.insts_size();
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  264) 
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  265)   Atomic::store(&_stub_size, size);
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  266) 
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  267)   return size;
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  268) }
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  269) 
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  270) int C2SafepointPollStubTable::estimate_stub_size() const {
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  271)   if (_safepoints.length() == 0) {
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  272)     return 0;
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  273)   }
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  274) 
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  275)   int result = stub_size_lazy() * _safepoints.length();
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  276) 
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  277) #ifdef ASSERT
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  278)   Compile* const C = Compile::current();
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  279)   BufferBlob* const blob = C->output()->scratch_buffer_blob();
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  280)   int size = 0;
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  281) 
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  282)   for (int i = _safepoints.length() - 1; i >= 0; i--) {
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  283)     CodeBuffer cb(blob->content_begin(), C->output()->scratch_buffer_code_size());
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  284)     MacroAssembler masm(&cb);
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  285)     C2SafepointPollStub* entry = _safepoints.at(i);
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  286)     emit_stub(masm, entry);
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  287)     size += cb.insts_size();
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  288)   }
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  289)   assert(size == result, "stubs should not have variable size");
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  290) #endif
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  291) 
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  292)   return result;
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000  293) }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  294) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  295) PhaseOutput::PhaseOutput()
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  296)   : Phase(Phase::Output),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  297)     _code_buffer("Compile::Fill_buffer"),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  298)     _first_block_size(0),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  299)     _handler_table(),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  300)     _inc_table(),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  301)     _oop_map_set(NULL),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  302)     _scratch_buffer_blob(NULL),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  303)     _scratch_locs_memory(NULL),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  304)     _scratch_const_size(-1),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  305)     _in_scratch_emit_size(false),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  306)     _frame_slots(0),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  307)     _code_offsets(),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  308)     _node_bundling_limit(0),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  309)     _node_bundling_base(NULL),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  310)     _orig_pc_slot(0),
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  311)     _orig_pc_slot_offset_in_bytes(0),
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  312)     _buf_sizes(),
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  313)     _block(NULL),
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  314)     _index(0) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  315)   C->set_output(this);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  316)   if (C->stub_name() == NULL) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  317)     _orig_pc_slot = C->fixed_slots() - (sizeof(address) / VMRegImpl::stack_slot_size);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  318)   }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  319) }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  320) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  321) PhaseOutput::~PhaseOutput() {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  322)   C->set_output(NULL);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  323)   if (_scratch_buffer_blob != NULL) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  324)     BufferBlob::free(_scratch_buffer_blob);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  325)   }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  326) }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  327) 
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  328) void PhaseOutput::perform_mach_node_analysis() {
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  329)   // Late barrier analysis must be done after schedule and bundle
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  330)   // Otherwise liveness based spilling will fail
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  331)   BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  332)   bs->late_barrier_analysis();
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  333) 
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  334)   pd_perform_mach_node_analysis();
4a41a5a0c45c src/hotspot/share/opto/output.cpp    (Nils Eliasson       2022-03-25 14:27:10 +0100  335)   // TODO temporary cahnge to level 1 below
4a41a5a0c45c src/hotspot/share/opto/output.cpp    (Nils Eliasson       2022-03-25 14:27:10 +0100  336)   // TODO when branch is rebased and tests can use PrintIdealPhase command - this can be reverted
4a41a5a0c45c src/hotspot/share/opto/output.cpp    (Nils Eliasson       2022-03-25 14:27:10 +0100  337)   C->print_method(CompilerPhaseType::PHASE_MACHANALYSIS, 1);
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  338) }
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  339) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  340) // Convert Nodes to instruction bits and pass off to the VM
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  341) void PhaseOutput::Output() {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  342)   // RootNode goes
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  343)   assert( C->cfg()->get_root_block()->number_of_nodes() == 0, "" );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  344) 
8dd34cd52f98 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2009-07-23 14:53:56 -0700  345)   // The number of new nodes (mostly MachNop) is proportional to
8dd34cd52f98 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2009-07-23 14:53:56 -0700  346)   // the number of java calls and inner loops which are aligned.
8dd34cd52f98 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2009-07-23 14:53:56 -0700  347)   if ( C->check_node_count((NodeLimitFudgeFactor + C->java_calls()*3 +
8dd34cd52f98 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2009-07-23 14:53:56 -0700  348)                             C->inner_loops()*(OptoLoopAlignment-1)),
8dd34cd52f98 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2009-07-23 14:53:56 -0700  349)                            "out of nodes before code generation" ) ) {
8dd34cd52f98 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2009-07-23 14:53:56 -0700  350)     return;
8dd34cd52f98 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2009-07-23 14:53:56 -0700  351)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  352)   // Make sure I can find the Start Node
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  353)   Block *entry = C->cfg()->get_block(1);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  354)   Block *broot = C->cfg()->get_root_block();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  355) 
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200  356)   const StartNode *start = entry->head()->as_Start();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  357) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  358)   // Replace StartNode with prolog
2a0815a55e21 hotspot/src/share/vm/opto/output.cpp (Tobias Hartmann     2014-06-02 08:07:29 +0200  359)   MachPrologNode *prolog = new MachPrologNode();
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200  360)   entry->map_node(prolog, 0);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  361)   C->cfg()->map_node_to_block(prolog, entry);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  362)   C->cfg()->unmap_node_from_block(start); // start is no longer in any block
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  363) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  364)   // Virtual methods need an unverified entry point
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  365) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  366)   if( C->is_osr_compilation() ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  367)     if( PoisonOSREntry ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  368)       // TODO: Should use a ShouldNotReachHereNode...
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  369)       C->cfg()->insert( broot, 0, new MachBreakpointNode() );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  370)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  371)   } else {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  372)     if( C->method() && !C->method()->flags().is_static() ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  373)       // Insert unvalidated entry point
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  374)       C->cfg()->insert( broot, 0, new MachUEPNode() );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  375)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  376) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  377)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  378) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  379)   // Break before main entry point
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  380)   if ((C->method() && C->directive()->BreakAtExecuteOption) ||
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  381)       (OptoBreakpoint && C->is_method_compilation())       ||
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  382)       (OptoBreakpointOSR && C->is_osr_compilation())       ||
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  383)       (OptoBreakpointC2R && !C->method())                   ) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  384)     // checking for C->method() means that OptoBreakpoint does not apply to
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  385)     // runtime stubs or frame converters
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  386)     C->cfg()->insert( entry, 1, new MachBreakpointNode() );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  387)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  388) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  389)   // Insert epilogs before every return
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  390)   for (uint i = 0; i < C->cfg()->number_of_blocks(); i++) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  391)     Block* block = C->cfg()->get_block(i);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  392)     if (!block->is_connector() && block->non_connector_successor(0) == C->cfg()->get_root_block()) { // Found a program exit point?
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200  393)       Node* m = block->end();
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200  394)       if (m->is_Mach() && m->as_Mach()->ideal_Opcode() != Op_Halt) {
2a0815a55e21 hotspot/src/share/vm/opto/output.cpp (Tobias Hartmann     2014-06-02 08:07:29 +0200  395)         MachEpilogNode* epilog = new MachEpilogNode(m->as_Mach()->ideal_Opcode() == Op_Return);
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200  396)         block->add_inst(epilog);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  397)         C->cfg()->map_node_to_block(epilog, block);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  398)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  399)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  400)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  401) 
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  402)   // Keeper of sizing aspects
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  403)   _buf_sizes = BufferSizingData();
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  404) 
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  405)   // Initialize code buffer
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  406)   estimate_buffer_size(_buf_sizes._const);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  407)   if (C->failing()) return;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  408) 
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  409)   // Pre-compute the length of blocks and replace
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  410)   // long branches with short if machine supports it.
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  411)   // Must be done before ScheduleAndBundle due to SPARC delay slots
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  412)   uint* blk_starts = NEW_RESOURCE_ARRAY(uint, C->cfg()->number_of_blocks() + 1);
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200  413)   blk_starts[0] = 0;
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  414)   shorten_branches(blk_starts);
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  415) 
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  416)   ScheduleAndBundle();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  417)   if (C->failing()) {
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200  418)     return;
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200  419)   }
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  420) 
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  421)   perform_mach_node_analysis();
ccdde4972871 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-02-24 14:37:30 +0000  422) 
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  423)   // Complete sizing of codebuffer
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  424)   CodeBuffer* cb = init_buffer();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  425)   if (cb == NULL || C->failing()) {
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200  426)     return;
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200  427)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  428) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  429)   BuildOopMaps();
cbc5a5f669a6 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-17 18:26:39 +0100  430) 
80ae8919c11f src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-17 18:10:26 +0100  431)   if (PrintBarrierSetStatistics) {
80ae8919c11f src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-17 18:10:26 +0100  432)     BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();
80ae8919c11f src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-17 18:10:26 +0100  433)     bs->gather_stats();
80ae8919c11f src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-17 18:10:26 +0100  434)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  435) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  436)   if (C->failing())  {
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200  437)     return;
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200  438)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  439) 
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  440)   fill_buffer(cb, blk_starts);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  441) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  442) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  443) bool PhaseOutput::need_stack_bang(int frame_size_in_bytes) const {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  444)   // Determine if we need to generate a stack overflow check.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  445)   // Do it if the method is not a stub function and
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  446)   // has java calls or has frame size > vm_page_size/8.
f5adc57f944a hotspot/src/share/vm/opto/output.cpp (Roland Westrelin    2014-04-01 09:36:49 +0200  447)   // The debug VM checks that deoptimization doesn't trigger an
f5adc57f944a hotspot/src/share/vm/opto/output.cpp (Roland Westrelin    2014-04-01 09:36:49 +0200  448)   // unexpected stack overflow (compiled method stack banging should
f5adc57f944a hotspot/src/share/vm/opto/output.cpp (Roland Westrelin    2014-04-01 09:36:49 +0200  449)   // guarantee it doesn't happen) so we always need the stack bang in
f5adc57f944a hotspot/src/share/vm/opto/output.cpp (Roland Westrelin    2014-04-01 09:36:49 +0200  450)   // a debug VM.
cf3e4bfdb5b5 src/hotspot/share/opto/output.cpp    (Harold Seigel       2021-01-11 18:18:13 +0000  451)   return (C->stub_function() == NULL &&
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  452)           (C->has_java_calls() || frame_size_in_bytes > os::vm_page_size()>>3
f5adc57f944a hotspot/src/share/vm/opto/output.cpp (Roland Westrelin    2014-04-01 09:36:49 +0200  453)            DEBUG_ONLY(|| true)));
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  454) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  455) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  456) bool PhaseOutput::need_register_stack_bang() const {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  457)   // Determine if we need to generate a register stack overflow check.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  458)   // This is only used on architectures which have split register
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  459)   // and memory stacks (ie. IA64).
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  460)   // Bang if the method is not a stub function and has java calls
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  461)   return (C->stub_function() == NULL && C->has_java_calls());
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  462) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  463) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  464) 
0e63b7609a2a hotspot/src/share/vm/opto/output.cpp (Chuck Rasbold       2008-11-06 14:59:10 -0800  465) // Compute the size of first NumberOfLoopInstrToAlign instructions at the top
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  466) // of a loop. When aligning a loop we need to provide enough instructions
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  467) // in cpu's fetch buffer to feed decoders. The loop alignment could be
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  468) // avoided if we have enough instructions in fetch buffer at the head of a loop.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  469) // By default, the size is set to 999999 by Block's constructor so that
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  470) // a loop will be aligned if the size is not reset here.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  471) //
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  472) // Note: Mach instructions could contain several HW instructions
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  473) // so the size is estimated only.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  474) //
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  475) void PhaseOutput::compute_loop_first_inst_sizes() {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  476)   // The next condition is used to gate the loop alignment optimization.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  477)   // Don't aligned a loop if there are enough instructions at the head of a loop
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  478)   // or alignment padding is larger then MaxLoopPad. By default, MaxLoopPad
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  479)   // is equal to OptoLoopAlignment-1 except on new Intel cpus, where it is
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  480)   // equal to 11 bytes which is the largest address NOP instruction.
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200  481)   if (MaxLoopPad < OptoLoopAlignment - 1) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  482)     uint last_block = C->cfg()->number_of_blocks() - 1;
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200  483)     for (uint i = 1; i <= last_block; i++) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  484)       Block* block = C->cfg()->get_block(i);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  485)       // Check the first loop's block which requires an alignment.
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200  486)       if (block->loop_alignment() > (uint)relocInfo::addr_unit()) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  487)         uint sum_size = 0;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  488)         uint inst_cnt = NumberOfLoopInstrToAlign;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  489)         inst_cnt = block->compute_first_inst_size(sum_size, inst_cnt, C->regalloc());
0e63b7609a2a hotspot/src/share/vm/opto/output.cpp (Chuck Rasbold       2008-11-06 14:59:10 -0800  490) 
0e63b7609a2a hotspot/src/share/vm/opto/output.cpp (Chuck Rasbold       2008-11-06 14:59:10 -0800  491)         // Check subsequent fallthrough blocks if the loop's first
0e63b7609a2a hotspot/src/share/vm/opto/output.cpp (Chuck Rasbold       2008-11-06 14:59:10 -0800  492)         // block(s) does not have enough instructions.
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200  493)         Block *nb = block;
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200  494)         while(inst_cnt > 0 &&
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200  495)               i < last_block &&
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  496)               !C->cfg()->get_block(i + 1)->has_loop_alignment() &&
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200  497)               !nb->has_successor(block)) {
0e63b7609a2a hotspot/src/share/vm/opto/output.cpp (Chuck Rasbold       2008-11-06 14:59:10 -0800  498)           i++;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  499)           nb = C->cfg()->get_block(i);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  500)           inst_cnt  = nb->compute_first_inst_size(sum_size, inst_cnt, C->regalloc());
0e63b7609a2a hotspot/src/share/vm/opto/output.cpp (Chuck Rasbold       2008-11-06 14:59:10 -0800  501)         } // while( inst_cnt > 0 && i < last_block  )
0e63b7609a2a hotspot/src/share/vm/opto/output.cpp (Chuck Rasbold       2008-11-06 14:59:10 -0800  502) 
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200  503)         block->set_first_inst_size(sum_size);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  504)       } // f( b->head()->is_Loop() )
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  505)     } // for( i <= last_block )
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  506)   } // if( MaxLoopPad < OptoLoopAlignment-1 )
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  507) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  508) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  509) // The architecture description provides short branch variants for some long
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  510) // branch instructions. Replace eligible long branches with short branches.
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  511) void PhaseOutput::shorten_branches(uint* blk_starts) {
38d690b3c347 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-05-19 17:51:02 +0000  512) 
38d690b3c347 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-05-19 17:51:02 +0000  513)   Compile::TracePhase tp("shorten branches", &timers[_t_shortenBranches]);
38d690b3c347 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-05-19 17:51:02 +0000  514) 
40e85ea300a9 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-19 20:25:07 +0100  515)   BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  516)   // Compute size of each block, method size, and relocation information size
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  517)   uint nblocks  = C->cfg()->number_of_blocks();
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  518) 
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  519)   uint*      jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  520)   uint*      jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  521)   int*       jmp_nidx   = NEW_RESOURCE_ARRAY(int ,nblocks);
2c99a4ef9f12 hotspot/src/share/vm/opto/output.cpp (Igor Veresov        2014-02-26 16:45:15 -0800  522) 
2c99a4ef9f12 hotspot/src/share/vm/opto/output.cpp (Igor Veresov        2014-02-26 16:45:15 -0800  523)   // Collect worst case block paddings
2c99a4ef9f12 hotspot/src/share/vm/opto/output.cpp (Igor Veresov        2014-02-26 16:45:15 -0800  524)   int* block_worst_case_pad = NEW_RESOURCE_ARRAY(int, nblocks);
2c99a4ef9f12 hotspot/src/share/vm/opto/output.cpp (Igor Veresov        2014-02-26 16:45:15 -0800  525)   memset(block_worst_case_pad, 0, nblocks * sizeof(int));
2c99a4ef9f12 hotspot/src/share/vm/opto/output.cpp (Igor Veresov        2014-02-26 16:45:15 -0800  526) 
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  527)   DEBUG_ONLY( uint *jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks); )
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  528)   DEBUG_ONLY( uint *jmp_rule = NEW_RESOURCE_ARRAY(uint,nblocks); )
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  529) 
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  530)   bool has_short_branch_candidate = false;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  531) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  532)   // Initialize the sizes to 0
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  533)   int code_size  = 0;          // Size in bytes of generated code
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  534)   int stub_size  = 0;          // Size in bytes of all stub entries
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  535)   // Size in bytes of all relocation entries, including those in local stubs.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  536)   // Start with 2-bytes of reloc info for the unvalidated entry point
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  537)   int reloc_size = 1;          // Number of relocation entries
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  538) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  539)   // Make three passes.  The first computes pessimistic blk_starts,
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  540)   // relative jmp_offset and reloc_size information.  The second performs
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800  541)   // short branch substitution using the pessimistic sizing.  The
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800  542)   // third inserts nops where needed.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  543) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  544)   // Step one, perform a pessimistic sizing pass.
adcde492fa7d hotspot/src/share/vm/opto/output.cpp (Zhengyu Gu          2014-05-07 06:03:31 -0700  545)   uint last_call_adr = max_juint;
adcde492fa7d hotspot/src/share/vm/opto/output.cpp (Zhengyu Gu          2014-05-07 06:03:31 -0700  546)   uint last_avoid_back_to_back_adr = max_juint;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  547)   uint nop_size = (new MachNopNode())->size(C->regalloc());
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  548)   for (uint i = 0; i < nblocks; i++) { // For all blocks
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  549)     Block* block = C->cfg()->get_block(i);
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  550)     _block = block;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  551) 
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  552)     // During short branch replacement, we store the relative (to blk_starts)
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  553)     // offset of jump in jmp_offset, rather than the absolute offset of jump.
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  554)     // This is so that we do not need to recompute sizes of all nodes when
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  555)     // we compute correct blk_starts in our next sizing pass.
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  556)     jmp_offset[i] = 0;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  557)     jmp_size[i]   = 0;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  558)     jmp_nidx[i]   = -1;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  559)     DEBUG_ONLY( jmp_target[i] = 0; )
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  560)     DEBUG_ONLY( jmp_rule[i]   = 0; )
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  561) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  562)     // Sum all instruction sizes to compute block size
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200  563)     uint last_inst = block->number_of_nodes();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  564)     uint blk_size = 0;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  565)     for (uint j = 0; j < last_inst; j++) {
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  566)       _index = j;
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  567)       Node* nj = block->get_node(_index);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  568)       // Handle machine instruction nodes
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  569)       if (nj->is_Mach()) {
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  570)         MachNode* mach = nj->as_Mach();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  571)         blk_size += (mach->alignment_required() - 1) * relocInfo::addr_unit(); // assume worst case padding
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  572)         reloc_size += mach->reloc();
3f42e9e11835 hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2013-04-24 20:55:28 -0400  573)         if (mach->is_MachCall()) {
ac75d4fc2fb3 hotspot/src/share/vm/opto/output.cpp (Lutz Schmidt        2014-03-25 12:54:21 -0700  574)           // add size information for trampoline stub
ac75d4fc2fb3 hotspot/src/share/vm/opto/output.cpp (Lutz Schmidt        2014-03-25 12:54:21 -0700  575)           // class CallStubImpl is platform-specific and defined in the *.ad files.
ac75d4fc2fb3 hotspot/src/share/vm/opto/output.cpp (Lutz Schmidt        2014-03-25 12:54:21 -0700  576)           stub_size  += CallStubImpl::size_call_trampoline();
ac75d4fc2fb3 hotspot/src/share/vm/opto/output.cpp (Lutz Schmidt        2014-03-25 12:54:21 -0700  577)           reloc_size += CallStubImpl::reloc_call_trampoline();
ac75d4fc2fb3 hotspot/src/share/vm/opto/output.cpp (Lutz Schmidt        2014-03-25 12:54:21 -0700  578) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  579)           MachCallNode *mcall = mach->as_MachCall();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  580)           // This destination address is NOT PC-relative
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  581) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  582)           mcall->method_set((intptr_t)mcall->entry_point());
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  583) 
3f42e9e11835 hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2013-04-24 20:55:28 -0400  584)           if (mcall->is_MachCallJava() && mcall->as_MachCallJava()->_method) {
3f42e9e11835 hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2013-04-24 20:55:28 -0400  585)             stub_size  += CompiledStaticCall::to_interp_stub_size();
3f42e9e11835 hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2013-04-24 20:55:28 -0400  586)             reloc_size += CompiledStaticCall::reloc_to_interp_stub();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  587)           }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  588)         } else if (mach->is_MachSafePoint()) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  589)           // If call/safepoint are adjacent, account for possible
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  590)           // nop to disambiguate the two safepoints.
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  591)           // ScheduleAndBundle() can rearrange nodes in a block,
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  592)           // check for all offsets inside this block.
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  593)           if (last_call_adr >= blk_starts[i]) {
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  594)             blk_size += nop_size;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  595)           }
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  596)         }
40e85ea300a9 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-19 20:25:07 +0100  597) 
40e85ea300a9 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-19 20:25:07 +0100  598)         blk_size += bs->estimate_mach_node_size(mach);
40e85ea300a9 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-19 20:25:07 +0100  599) 
e6456ff2a4ef hotspot/src/share/vm/opto/output.cpp (Igor Veresov        2014-04-10 23:15:13 -0700  600)         if (mach->avoid_back_to_back(MachNode::AVOID_BEFORE)) {
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  601)           // Nop is inserted between "avoid back to back" instructions.
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  602)           // ScheduleAndBundle() can rearrange nodes in a block,
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  603)           // check for all offsets inside this block.
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  604)           if (last_avoid_back_to_back_adr >= blk_starts[i]) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  605)             blk_size += nop_size;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  606)           }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  607)         }
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  608)         if (mach->may_be_short_branch()) {
080f790edc7f hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-16 11:53:57 -0700  609)           if (!nj->is_MachBranch()) {
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  610) #ifndef PRODUCT
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  611)             nj->dump(3);
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  612) #endif
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  613)             Unimplemented();
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  614)           }
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  615)           assert(jmp_nidx[i] == -1, "block should have only one branch");
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  616)           jmp_offset[i] = blk_size;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  617)           jmp_size[i]   = nj->size(C->regalloc());
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  618)           jmp_nidx[i]   = j;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  619)           has_short_branch_candidate = true;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  620)         }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  621)       }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  622)       blk_size += nj->size(C->regalloc());
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  623)       // Remember end of call offset
18329266ea16 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-07-27 17:28:36 -0700  624)       if (nj->is_MachCall() && !nj->is_MachCallLeaf()) {
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  625)         last_call_adr = blk_starts[i]+blk_size;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  626)       }
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  627)       // Remember end of avoid_back_to_back offset
e6456ff2a4ef hotspot/src/share/vm/opto/output.cpp (Igor Veresov        2014-04-10 23:15:13 -0700  628)       if (nj->is_Mach() && nj->as_Mach()->avoid_back_to_back(MachNode::AVOID_AFTER)) {
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  629)         last_avoid_back_to_back_adr = blk_starts[i]+blk_size;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  630)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  631)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  632) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  633)     // When the next block starts a loop, we may insert pad NOP
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  634)     // instructions.  Since we cannot know our future alignment,
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  635)     // assume the worst.
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200  636)     if (i < nblocks - 1) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  637)       Block* nb = C->cfg()->get_block(i + 1);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  638)       int max_loop_pad = nb->code_alignment()-relocInfo::addr_unit();
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  639)       if (max_loop_pad > 0) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  640)         assert(is_power_of_2(max_loop_pad+relocInfo::addr_unit()), "");
93c40233d6fa hotspot/src/share/vm/opto/output.cpp (Chuck Rasbold       2013-04-03 15:00:55 -0700  641)         // Adjust last_call_adr and/or last_avoid_back_to_back_adr.
93c40233d6fa hotspot/src/share/vm/opto/output.cpp (Chuck Rasbold       2013-04-03 15:00:55 -0700  642)         // If either is the last instruction in this block, bump by
93c40233d6fa hotspot/src/share/vm/opto/output.cpp (Chuck Rasbold       2013-04-03 15:00:55 -0700  643)         // max_loop_pad in lock-step with blk_size, so sizing
93c40233d6fa hotspot/src/share/vm/opto/output.cpp (Chuck Rasbold       2013-04-03 15:00:55 -0700  644)         // calculations in subsequent blocks still can conservatively
93c40233d6fa hotspot/src/share/vm/opto/output.cpp (Chuck Rasbold       2013-04-03 15:00:55 -0700  645)         // detect that it may the last instruction in this block.
93c40233d6fa hotspot/src/share/vm/opto/output.cpp (Chuck Rasbold       2013-04-03 15:00:55 -0700  646)         if (last_call_adr == blk_starts[i]+blk_size) {
93c40233d6fa hotspot/src/share/vm/opto/output.cpp (Chuck Rasbold       2013-04-03 15:00:55 -0700  647)           last_call_adr += max_loop_pad;
93c40233d6fa hotspot/src/share/vm/opto/output.cpp (Chuck Rasbold       2013-04-03 15:00:55 -0700  648)         }
93c40233d6fa hotspot/src/share/vm/opto/output.cpp (Chuck Rasbold       2013-04-03 15:00:55 -0700  649)         if (last_avoid_back_to_back_adr == blk_starts[i]+blk_size) {
93c40233d6fa hotspot/src/share/vm/opto/output.cpp (Chuck Rasbold       2013-04-03 15:00:55 -0700  650)           last_avoid_back_to_back_adr += max_loop_pad;
93c40233d6fa hotspot/src/share/vm/opto/output.cpp (Chuck Rasbold       2013-04-03 15:00:55 -0700  651)         }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  652)         blk_size += max_loop_pad;
2c99a4ef9f12 hotspot/src/share/vm/opto/output.cpp (Igor Veresov        2014-02-26 16:45:15 -0800  653)         block_worst_case_pad[i + 1] = max_loop_pad;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  654)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  655)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  656) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  657)     // Save block size; update total method size
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  658)     blk_starts[i+1] = blk_starts[i]+blk_size;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  659)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  660) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  661)   // Step two, replace eligible long jumps.
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  662)   bool progress = true;
adcde492fa7d hotspot/src/share/vm/opto/output.cpp (Zhengyu Gu          2014-05-07 06:03:31 -0700  663)   uint last_may_be_short_branch_adr = max_juint;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  664)   while (has_short_branch_candidate && progress) {
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  665)     progress = false;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  666)     has_short_branch_candidate = false;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  667)     int adjust_block_start = 0;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  668)     for (uint i = 0; i < nblocks; i++) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  669)       Block* block = C->cfg()->get_block(i);
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  670)       int idx = jmp_nidx[i];
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200  671)       MachNode* mach = (idx == -1) ? NULL: block->get_node(idx)->as_Mach();
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  672)       if (mach != NULL && mach->may_be_short_branch()) {
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  673) #ifdef ASSERT
080f790edc7f hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-16 11:53:57 -0700  674)         assert(jmp_size[i] > 0 && mach->is_MachBranch(), "sanity");
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  675)         int j;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  676)         // Find the branch; ignore trailing NOPs.
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200  677)         for (j = block->number_of_nodes()-1; j>=0; j--) {
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200  678)           Node* n = block->get_node(j);
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  679)           if (!n->is_Mach() || n->as_Mach()->ideal_Opcode() != Op_Con)
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  680)             break;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  681)         }
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200  682)         assert(j >= 0 && j == idx && block->get_node(j) == (Node*)mach, "sanity");
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  683) #endif
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  684)         int br_size = jmp_size[i];
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  685)         int br_offs = blk_starts[i] + jmp_offset[i];
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  686) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  687)         // This requires the TRUE branch target be in succs[0]
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200  688)         uint bnum = block->non_connector_successor(0)->_pre_order;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  689)         int offset = blk_starts[bnum] - br_offs;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  690)         if (bnum > i) { // adjust following block's offset
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  691)           offset -= adjust_block_start;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  692)         }
2c99a4ef9f12 hotspot/src/share/vm/opto/output.cpp (Igor Veresov        2014-02-26 16:45:15 -0800  693) 
2c99a4ef9f12 hotspot/src/share/vm/opto/output.cpp (Igor Veresov        2014-02-26 16:45:15 -0800  694)         // This block can be a loop header, account for the padding
2c99a4ef9f12 hotspot/src/share/vm/opto/output.cpp (Igor Veresov        2014-02-26 16:45:15 -0800  695)         // in the previous block.
2c99a4ef9f12 hotspot/src/share/vm/opto/output.cpp (Igor Veresov        2014-02-26 16:45:15 -0800  696)         int block_padding = block_worst_case_pad[i];
2c99a4ef9f12 hotspot/src/share/vm/opto/output.cpp (Igor Veresov        2014-02-26 16:45:15 -0800  697)         assert(i == 0 || block_padding == 0 || br_offs >= block_padding, "Should have at least a padding on top");
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  698)         // In the following code a nop could be inserted before
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  699)         // the branch which will increase the backward distance.
2c99a4ef9f12 hotspot/src/share/vm/opto/output.cpp (Igor Veresov        2014-02-26 16:45:15 -0800  700)         bool needs_padding = ((uint)(br_offs - block_padding) == last_may_be_short_branch_adr);
2c99a4ef9f12 hotspot/src/share/vm/opto/output.cpp (Igor Veresov        2014-02-26 16:45:15 -0800  701)         assert(!needs_padding || jmp_offset[i] == 0, "padding only branches at the beginning of block");
2c99a4ef9f12 hotspot/src/share/vm/opto/output.cpp (Igor Veresov        2014-02-26 16:45:15 -0800  702) 
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  703)         if (needs_padding && offset <= 0)
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  704)           offset -= nop_size;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  705) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  706)         if (C->matcher()->is_short_branch_offset(mach->rule(), br_size, offset)) {
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  707)           // We've got a winner.  Replace this branch.
70a55eac34c6 hotspot/src/share/vm/opto/output.cpp (Tobias Hartmann     2014-08-05 09:58:52 +0200  708)           MachNode* replacement = mach->as_MachBranch()->short_branch_version();
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  709) 
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  710)           // Update the jmp_size.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  711)           int new_size = replacement->size(C->regalloc());
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  712)           int diff     = br_size - new_size;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  713)           assert(diff >= (int)nop_size, "short_branch size should be smaller");
e6456ff2a4ef hotspot/src/share/vm/opto/output.cpp (Igor Veresov        2014-04-10 23:15:13 -0700  714)           // Conservatively take into account padding between
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  715)           // avoid_back_to_back branches. Previous branch could be
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  716)           // converted into avoid_back_to_back branch during next
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  717)           // rounds.
e6456ff2a4ef hotspot/src/share/vm/opto/output.cpp (Igor Veresov        2014-04-10 23:15:13 -0700  718)           if (needs_padding && replacement->avoid_back_to_back(MachNode::AVOID_BEFORE)) {
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  719)             jmp_offset[i] += nop_size;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  720)             diff -= nop_size;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  721)           }
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  722)           adjust_block_start += diff;
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200  723)           block->map_node(replacement, idx);
2d2532e74001 hotspot/src/share/vm/opto/output.cpp (Bharadwaj Yadavalli 2012-11-27 17:24:15 -0800  724)           mach->subsume_by(replacement, C);
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  725)           mach = replacement;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  726)           progress = true;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  727) 
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  728)           jmp_size[i] = new_size;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  729)           DEBUG_ONLY( jmp_target[i] = bnum; );
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  730)           DEBUG_ONLY( jmp_rule[i] = mach->rule(); );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  731)         } else {
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  732)           // The jump distance is not short, try again during next iteration.
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  733)           has_short_branch_candidate = true;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  734)         }
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  735)       } // (mach->may_be_short_branch())
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  736)       if (mach != NULL && (mach->may_be_short_branch() ||
e6456ff2a4ef hotspot/src/share/vm/opto/output.cpp (Igor Veresov        2014-04-10 23:15:13 -0700  737)                            mach->avoid_back_to_back(MachNode::AVOID_AFTER))) {
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  738)         last_may_be_short_branch_adr = blk_starts[i] + jmp_offset[i] + jmp_size[i];
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  739)       }
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  740)       blk_starts[i+1] -= adjust_block_start;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  741)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  742)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  743) 
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  744) #ifdef ASSERT
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  745)   for (uint i = 0; i < nblocks; i++) { // For all blocks
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  746)     if (jmp_target[i] != 0) {
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  747)       int br_size = jmp_size[i];
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  748)       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  749)       if (!C->matcher()->is_short_branch_offset(jmp_rule[i], br_size, offset)) {
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  750)         tty->print_cr("target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d", blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  751)       }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  752)       assert(C->matcher()->is_short_branch_offset(jmp_rule[i], br_size, offset), "Displacement too large for short jmp");
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  753)     }
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  754)   }
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  755) #endif
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  756) 
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700  757)   // Step 3, compute the offsets of all blocks, will be done in fill_buffer()
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  758)   // after ScheduleAndBundle().
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  759) 
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  760)   // ------------------
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  761)   // Compute size for code buffer
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  762)   code_size = blk_starts[nblocks];
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  763) 
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  764)   // Relocation records
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  765)   reloc_size += 1;              // Relo entry for exception handler
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  766) 
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  767)   // Adjust reloc_size to number of record of relocation info
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  768)   // Min is 2 bytes, max is probably 6 or 8, with a tax up to 25% for
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  769)   // a relocation index.
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  770)   // The CodeBuffer will expand the locs array if this estimate is too low.
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  771)   reloc_size *= 10 / sizeof(relocInfo);
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  772) 
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  773)   _buf_sizes._reloc = reloc_size;
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  774)   _buf_sizes._code  = code_size;
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000  775)   _buf_sizes._stub  = stub_size;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  776) }
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700  777) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  778) //------------------------------FillLocArray-----------------------------------
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  779) // Create a bit of debug info and append it to the array.  The mapping is from
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  780) // Java local or expression stack to constant, register or stack-slot.  For
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  781) // doubles, insert 2 mappings and return 1 (to tell the caller that the next
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  782) // entry has been taken care of and caller should skip it).
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  783) static LocationValue *new_loc_value( PhaseRegAlloc *ra, OptoReg::Name regnum, Location::Type l_type ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  784)   // This should never have accepted Bad before
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  785)   assert(OptoReg::is_valid(regnum), "location must be valid");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  786)   return (OptoReg::is_reg(regnum))
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  787)          ? new LocationValue(Location::new_reg_loc(l_type, OptoReg::as_VMReg(regnum)) )
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  788)          : new LocationValue(Location::new_stk_loc(l_type,  ra->reg2offset(regnum)));
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  789) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  790) 
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  791) 
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  792) ObjectValue*
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  793) PhaseOutput::sv_for_node_id(GrowableArray<ScopeValue*> *objs, int id) {
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  794)   for (int i = 0; i < objs->length(); i++) {
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  795)     assert(objs->at(i)->is_object(), "corrupt object cache");
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  796)     ObjectValue* sv = (ObjectValue*) objs->at(i);
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  797)     if (sv->id() == id) {
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  798)       return sv;
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  799)     }
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  800)   }
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  801)   // Otherwise..
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  802)   return NULL;
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  803) }
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  804) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  805) void PhaseOutput::set_sv_for_object_node(GrowableArray<ScopeValue*> *objs,
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  806)                                      ObjectValue* sv ) {
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  807)   assert(sv_for_node_id(objs, sv->id()) == NULL, "Precondition");
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  808)   objs->append(sv);
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  809) }
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  810) 
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  811) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  812) void PhaseOutput::FillLocArray( int idx, MachSafePointNode* sfpt, Node *local,
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  813)                             GrowableArray<ScopeValue*> *array,
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  814)                             GrowableArray<ScopeValue*> *objs ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  815)   assert( local, "use _top instead of null" );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  816)   if (array->length() != idx) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  817)     assert(array->length() == idx + 1, "Unexpected array count");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  818)     // Old functionality:
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  819)     //   return
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  820)     // New functionality:
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  821)     //   Assert if the local is not top. In product mode let the new node
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  822)     //   override the old entry.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  823)     assert(local == C->top(), "LocArray collision");
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  824)     if (local == C->top()) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  825)       return;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  826)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  827)     array->pop();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  828)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  829)   const Type *t = local->bottom_type();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  830) 
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  831)   // Is it a safepoint scalar object node?
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  832)   if (local->is_SafePointScalarObject()) {
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  833)     SafePointScalarObjectNode* spobj = local->as_SafePointScalarObject();
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  834) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  835)     ObjectValue* sv = sv_for_node_id(objs, spobj->_idx);
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  836)     if (sv == NULL) {
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  837)       ciKlass* cik = t->is_oopptr()->klass();
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  838)       assert(cik->is_instance_klass() ||
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  839)              cik->is_array_klass(), "Not supported allocation.");
eab84554e829 src/hotspot/share/opto/output.cpp    (Wang Huang          2021-04-07 10:48:17 +0000  840)       ScopeValue* klass_sv = new ConstantOopWriteValue(cik->java_mirror()->constant_encoding());
eab84554e829 src/hotspot/share/opto/output.cpp    (Wang Huang          2021-04-07 10:48:17 +0000  841)       sv = spobj->is_auto_box() ? new AutoBoxObjectValue(spobj->_idx, klass_sv)
eab84554e829 src/hotspot/share/opto/output.cpp    (Wang Huang          2021-04-07 10:48:17 +0000  842)                                     : new ObjectValue(spobj->_idx, klass_sv);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  843)       set_sv_for_object_node(objs, sv);
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  844) 
ccfb92c6a964 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2013-08-23 11:41:37 -0700  845)       uint first_ind = spobj->first_index(sfpt->jvms());
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  846)       for (uint i = 0; i < spobj->n_fields(); i++) {
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  847)         Node* fld_node = sfpt->in(first_ind+i);
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  848)         (void)FillLocArray(sv->field_values()->length(), sfpt, fld_node, sv->field_values(), objs);
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  849)       }
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  850)     }
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  851)     array->append(sv);
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  852)     return;
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  853)   }
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700  854) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  855)   // Grab the register number for the local
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  856)   OptoReg::Name regnum = C->regalloc()->get_reg_first(local);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  857)   if( OptoReg::is_valid(regnum) ) {// Got a register/stack?
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  858)     // Record the double as two float registers.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  859)     // The register mask for such a value always specifies two adjacent
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  860)     // float registers, with the lower register number even.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  861)     // Normally, the allocation of high and low words to these registers
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  862)     // is irrelevant, because nearly all operations on register pairs
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  863)     // (e.g., StoreD) treat them as a single unit.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  864)     // Here, we assume in addition that the words in these two registers
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  865)     // stored "naturally" (by operations like StoreD and double stores
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  866)     // within the interpreter) such that the lower-numbered register
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  867)     // is written to the lower memory address.  This may seem like
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  868)     // a machine dependency, but it is not--it is a requirement on
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  869)     // the author of the <arch>.ad file to ensure that, for every
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  870)     // even/odd double-register pair to which a double may be allocated,
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  871)     // the word in the even single-register is stored to the first
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  872)     // memory word.  (Note that register numbers are completely
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  873)     // arbitrary, and are not tied to any machine-level encodings.)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  874) #ifdef _LP64
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  875)     if( t->base() == Type::DoubleBot || t->base() == Type::DoubleCon ) {
e908052a715d src/hotspot/share/opto/output.cpp    (Coleen Phillimore   2017-10-31 11:55:09 -0400  876)       array->append(new ConstantIntValue((jint)0));
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  877)       array->append(new_loc_value( C->regalloc(), regnum, Location::dbl ));
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  878)     } else if ( t->base() == Type::Long ) {
e908052a715d src/hotspot/share/opto/output.cpp    (Coleen Phillimore   2017-10-31 11:55:09 -0400  879)       array->append(new ConstantIntValue((jint)0));
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  880)       array->append(new_loc_value( C->regalloc(), regnum, Location::lng ));
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  881)     } else if ( t->base() == Type::RawPtr ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  882)       // jsr/ret return address which must be restored into a the full
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  883)       // width 64-bit stack slot.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  884)       array->append(new_loc_value( C->regalloc(), regnum, Location::lng ));
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  885)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  886) #else //_LP64
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  887)     if( t->base() == Type::DoubleBot || t->base() == Type::DoubleCon || t->base() == Type::Long ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  888)       // Repack the double/long as two jints.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  889)       // The convention the interpreter uses is that the second local
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  890)       // holds the first raw word of the native double representation.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  891)       // This is actually reasonable, since locals and stack arrays
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  892)       // grow downwards in all implementations.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  893)       // (If, on some machine, the interpreter's Java locals or stack
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  894)       // were to grow upwards, the embedded doubles would be word-swapped.)
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  895)       array->append(new_loc_value( C->regalloc(), OptoReg::add(regnum,1), Location::normal ));
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  896)       array->append(new_loc_value( C->regalloc(),              regnum   , Location::normal ));
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  897)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  898) #endif //_LP64
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  899)     else if( (t->base() == Type::FloatBot || t->base() == Type::FloatCon) &&
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  900)              OptoReg::is_reg(regnum) ) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  901)       array->append(new_loc_value( C->regalloc(), regnum, Matcher::float_in_double()
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  902)                                                       ? Location::float_in_dbl : Location::normal ));
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  903)     } else if( t->base() == Type::Int && OptoReg::is_reg(regnum) ) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  904)       array->append(new_loc_value( C->regalloc(), regnum, Matcher::int_in_long
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  905)                                                       ? Location::int_in_long : Location::normal ));
659ca734bb71 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-09-10 18:23:32 -0700  906)     } else if( t->base() == Type::NarrowOop ) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  907)       array->append(new_loc_value( C->regalloc(), regnum, Location::narrowoop ));
42a6eadb853d src/hotspot/share/opto/output.cpp    (Ningsheng Jian      2020-10-21 01:15:13 +0000  908)     } else if (t->base() == Type::VectorA || t->base() == Type::VectorS ||
42a6eadb853d src/hotspot/share/opto/output.cpp    (Ningsheng Jian      2020-10-21 01:15:13 +0000  909)                t->base() == Type::VectorD || t->base() == Type::VectorX ||
42a6eadb853d src/hotspot/share/opto/output.cpp    (Ningsheng Jian      2020-10-21 01:15:13 +0000  910)                t->base() == Type::VectorY || t->base() == Type::VectorZ) {
0c99b192588b src/hotspot/share/opto/output.cpp    (Paul Sandoz         2020-10-14 20:02:46 +0000  911)       array->append(new_loc_value( C->regalloc(), regnum, Location::vector ));
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  912)     } else {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000  913)       array->append(new_loc_value( C->regalloc(), regnum, C->regalloc()->is_oop(local) ? Location::oop : Location::normal ));
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  914)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  915)     return;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  916)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  917) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  918)   // No register.  It must be constant data.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  919)   switch (t->base()) {
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  920)     case Type::Half:              // Second half of a double
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  921)       ShouldNotReachHere();       // Caller should skip 2nd halves
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  922)       break;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  923)     case Type::AnyPtr:
659ca734bb71 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-09-10 18:23:32 -0700  924)       array->append(new ConstantOopWriteValue(NULL));
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  925)       break;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  926)     case Type::AryPtr:
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  927)     case Type::InstPtr:          // fall through
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  928)       array->append(new ConstantOopWriteValue(t->isa_oopptr()->const_oop()->constant_encoding()));
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  929)       break;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  930)     case Type::NarrowOop:
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  931)       if (t == TypeNarrowOop::NULL_PTR) {
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  932)         array->append(new ConstantOopWriteValue(NULL));
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  933)       } else {
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  934)         array->append(new ConstantOopWriteValue(t->make_ptr()->isa_oopptr()->const_oop()->constant_encoding()));
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  935)       }
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  936)       break;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  937)     case Type::Int:
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  938)       array->append(new ConstantIntValue(t->is_int()->get_con()));
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  939)       break;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  940)     case Type::RawPtr:
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  941)       // A return address (T_ADDRESS).
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  942)       assert((intptr_t)t->is_ptr()->get_con() < (intptr_t)0x10000, "must be a valid BCI");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  943) #ifdef _LP64
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  944)       // Must be restored to the full-width 64-bit stack slot.
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  945)       array->append(new ConstantLongValue(t->is_ptr()->get_con()));
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  946) #else
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  947)       array->append(new ConstantIntValue(t->is_ptr()->get_con()));
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  948) #endif
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  949)       break;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  950)     case Type::FloatCon: {
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  951)       float f = t->is_float_constant()->getf();
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  952)       array->append(new ConstantIntValue(jint_cast(f)));
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  953)       break;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  954)     }
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  955)     case Type::DoubleCon: {
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  956)       jdouble d = t->is_double_constant()->getd();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  957) #ifdef _LP64
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  958)       array->append(new ConstantIntValue((jint)0));
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  959)       array->append(new ConstantDoubleValue(d));
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  960) #else
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  961)       // Repack the double as two jints.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  962)     // The convention the interpreter uses is that the second local
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  963)     // holds the first raw word of the native double representation.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  964)     // This is actually reasonable, since locals and stack arrays
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  965)     // grow downwards in all implementations.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  966)     // (If, on some machine, the interpreter's Java locals or stack
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  967)     // were to grow upwards, the embedded doubles would be word-swapped.)
e546e2a060e8 hotspot/src/share/vm/opto/output.cpp (Roland Westrelin    2014-07-31 19:59:36 +0200  968)     jlong_accessor acc;
e546e2a060e8 hotspot/src/share/vm/opto/output.cpp (Roland Westrelin    2014-07-31 19:59:36 +0200  969)     acc.long_value = jlong_cast(d);
d2a5b70cdfe0 hotspot/src/share/vm/opto/output.cpp (Tobias Hartmann     2014-07-29 13:54:16 +0200  970)     array->append(new ConstantIntValue(acc.words[1]));
d2a5b70cdfe0 hotspot/src/share/vm/opto/output.cpp (Tobias Hartmann     2014-07-29 13:54:16 +0200  971)     array->append(new ConstantIntValue(acc.words[0]));
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  972) #endif
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  973)       break;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  974)     }
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  975)     case Type::Long: {
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  976)       jlong d = t->is_long()->get_con();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  977) #ifdef _LP64
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  978)       array->append(new ConstantIntValue((jint)0));
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  979)       array->append(new ConstantLongValue(d));
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  980) #else
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  981)       // Repack the long as two jints.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  982)     // The convention the interpreter uses is that the second local
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  983)     // holds the first raw word of the native double representation.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  984)     // This is actually reasonable, since locals and stack arrays
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  985)     // grow downwards in all implementations.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  986)     // (If, on some machine, the interpreter's Java locals or stack
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  987)     // were to grow upwards, the embedded doubles would be word-swapped.)
e546e2a060e8 hotspot/src/share/vm/opto/output.cpp (Roland Westrelin    2014-07-31 19:59:36 +0200  988)     jlong_accessor acc;
e546e2a060e8 hotspot/src/share/vm/opto/output.cpp (Roland Westrelin    2014-07-31 19:59:36 +0200  989)     acc.long_value = d;
d2a5b70cdfe0 hotspot/src/share/vm/opto/output.cpp (Tobias Hartmann     2014-07-29 13:54:16 +0200  990)     array->append(new ConstantIntValue(acc.words[1]));
d2a5b70cdfe0 hotspot/src/share/vm/opto/output.cpp (Tobias Hartmann     2014-07-29 13:54:16 +0200  991)     array->append(new ConstantIntValue(acc.words[0]));
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000  992) #endif
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  993)       break;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  994)     }
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  995)     case Type::Top:               // Add an illegal value here
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  996)       array->append(new LocationValue(Location()));
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  997)       break;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  998)     default:
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000  999)       ShouldNotReachHere();
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1000)       break;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1001)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1002) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1003) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1004) // Determine if this node starts a bundle
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1005) bool PhaseOutput::starts_bundle(const Node *n) const {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1006)   return (_node_bundling_limit > n->_idx &&
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1007)           _node_bundling_base[n->_idx].starts_bundle());
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1008) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1009) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1010) //--------------------------Process_OopMap_Node--------------------------------
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1011) void PhaseOutput::Process_OopMap_Node(MachNode *mach, int current_offset) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1012)   // Handle special safepoint nodes for synchronization
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1013)   MachSafePointNode *sfn   = mach->as_MachSafePoint();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1014)   MachCallNode      *mcall;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1015) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1016)   int safepoint_pc_offset = current_offset;
375527d84eaf hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-01-05 13:05:58 +0100 1017)   bool is_method_handle_invoke = false;
0fb31dbf3a2a src/hotspot/share/opto/output.cpp    (Maurizio Cimadamore 2020-11-23 11:00:38 +0000 1018)   bool is_opt_native = false;
22409a570407 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2010-02-09 01:31:13 -0800 1019)   bool return_oop = false;
40f847e2fb5a src/hotspot/share/opto/output.cpp    (Richard Reingruber  2020-10-20 15:31:55 +0000 1020)   bool has_ea_local_in_scope = sfn->_has_ea_local_in_scope;
40f847e2fb5a src/hotspot/share/opto/output.cpp    (Richard Reingruber  2020-10-20 15:31:55 +0000 1021)   bool arg_escape = false;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1022) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1023)   // Add the safepoint in the DebugInfoRecorder
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1024)   if( !mach->is_MachCall() ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1025)     mcall = NULL;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1026)     C->debug_info()->add_safepoint(safepoint_pc_offset, sfn->_oop_map);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1027)   } else {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1028)     mcall = mach->as_MachCall();
375527d84eaf hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-01-05 13:05:58 +0100 1029) 
375527d84eaf hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-01-05 13:05:58 +0100 1030)     // Is the call a MethodHandle call?
0c605ed991d7 hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-02-18 11:35:41 +0100 1031)     if (mcall->is_MachCallJava()) {
0c605ed991d7 hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-02-18 11:35:41 +0100 1032)       if (mcall->as_MachCallJava()->_method_handle_invoke) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1033)         assert(C->has_method_handle_invokes(), "must have been set during call generation");
0c605ed991d7 hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-02-18 11:35:41 +0100 1034)         is_method_handle_invoke = true;
0c605ed991d7 hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-02-18 11:35:41 +0100 1035)       }
40f847e2fb5a src/hotspot/share/opto/output.cpp    (Richard Reingruber  2020-10-20 15:31:55 +0000 1036)       arg_escape = mcall->as_MachCallJava()->_arg_escape;
0fb31dbf3a2a src/hotspot/share/opto/output.cpp    (Maurizio Cimadamore 2020-11-23 11:00:38 +0000 1037)     } else if (mcall->is_MachCallNative()) {
0fb31dbf3a2a src/hotspot/share/opto/output.cpp    (Maurizio Cimadamore 2020-11-23 11:00:38 +0000 1038)       is_opt_native = true;
0c605ed991d7 hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-02-18 11:35:41 +0100 1039)     }
375527d84eaf hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-01-05 13:05:58 +0100 1040) 
22409a570407 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2010-02-09 01:31:13 -0800 1041)     // Check if a call returns an object.
1379a7f2f071 hotspot/src/share/vm/opto/output.cpp (David Chase         2014-07-11 19:51:36 -0400 1042)     if (mcall->returns_pointer()) {
22409a570407 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2010-02-09 01:31:13 -0800 1043)       return_oop = true;
22409a570407 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2010-02-09 01:31:13 -0800 1044)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1045)     safepoint_pc_offset += mcall->ret_addr_offset();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1046)     C->debug_info()->add_safepoint(safepoint_pc_offset, mcall->_oop_map);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1047)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1048) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1049)   // Loop over the JVMState list to add scope information
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1050)   // Do not skip safepoints with a NULL method, they need monitor info
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1051)   JVMState* youngest_jvms = sfn->jvms();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1052)   int max_depth = youngest_jvms->depth();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1053) 
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700 1054)   // Allocate the object pool for scalar-replaced objects -- the map from
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700 1055)   // small-integer keys (which can be recorded in the local and ostack
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700 1056)   // arrays) to descriptions of the object state.
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700 1057)   GrowableArray<ScopeValue*> *objs = new GrowableArray<ScopeValue*>();
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700 1058) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1059)   // Visit scopes from oldest to youngest.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1060)   for (int depth = 1; depth <= max_depth; depth++) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1061)     JVMState* jvms = youngest_jvms->of_depth(depth);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1062)     int idx;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1063)     ciMethod* method = jvms->has_method() ? jvms->method() : NULL;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1064)     // Safepoints that do not have method() set only provide oop-map and monitor info
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1065)     // to support GC; these do not support deoptimization.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1066)     int num_locs = (method == NULL) ? 0 : jvms->loc_size();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1067)     int num_exps = (method == NULL) ? 0 : jvms->stk_size();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1068)     int num_mon  = jvms->nof_monitors();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1069)     assert(method == NULL || jvms->bci() < 0 || num_locs == method->max_locals(),
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1070)            "JVMS local count must match that of the method");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1071) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1072)     // Add Local and Expression Stack Information
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1073) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1074)     // Insert locals into the locarray
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1075)     GrowableArray<ScopeValue*> *locarray = new GrowableArray<ScopeValue*>(num_locs);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1076)     for( idx = 0; idx < num_locs; idx++ ) {
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700 1077)       FillLocArray( idx, sfn, sfn->local(jvms, idx), locarray, objs );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1078)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1079) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1080)     // Insert expression stack entries into the exparray
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1081)     GrowableArray<ScopeValue*> *exparray = new GrowableArray<ScopeValue*>(num_exps);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1082)     for( idx = 0; idx < num_exps; idx++ ) {
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700 1083)       FillLocArray( idx,  sfn, sfn->stack(jvms, idx), exparray, objs );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1084)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1085) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1086)     // Add in mappings of the monitors
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1087)     assert( !method ||
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1088)             !method->is_synchronized() ||
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1089)             method->is_native() ||
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1090)             num_mon > 0 ||
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1091)             !GenerateSynchronizationCode,
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1092)             "monitors must always exist for synchronized methods");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1093) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1094)     // Build the growable array of ScopeValues for exp stack
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1095)     GrowableArray<MonitorValue*> *monarray = new GrowableArray<MonitorValue*>(num_mon);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1096) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1097)     // Loop over monitors and insert into array
ccfb92c6a964 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2013-08-23 11:41:37 -0700 1098)     for (idx = 0; idx < num_mon; idx++) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1099)       // Grab the node that defines this monitor
f2f18a01e514 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-12-03 13:41:37 -0800 1100)       Node* box_node = sfn->monitor_box(jvms, idx);
f2f18a01e514 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-12-03 13:41:37 -0800 1101)       Node* obj_node = sfn->monitor_obj(jvms, idx);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1102) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1103)       // Create ScopeValue for object
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1104)       ScopeValue *scval = NULL;
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700 1105) 
ccfb92c6a964 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2013-08-23 11:41:37 -0700 1106)       if (obj_node->is_SafePointScalarObject()) {
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700 1107)         SafePointScalarObjectNode* spobj = obj_node->as_SafePointScalarObject();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1108)         scval = PhaseOutput::sv_for_node_id(objs, spobj->_idx);
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700 1109)         if (scval == NULL) {
ccfb92c6a964 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2013-08-23 11:41:37 -0700 1110)           const Type *t = spobj->bottom_type();
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700 1111)           ciKlass* cik = t->is_oopptr()->klass();
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700 1112)           assert(cik->is_instance_klass() ||
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700 1113)                  cik->is_array_klass(), "Not supported allocation.");
eab84554e829 src/hotspot/share/opto/output.cpp    (Wang Huang          2021-04-07 10:48:17 +0000 1114)           ScopeValue* klass_sv = new ConstantOopWriteValue(cik->java_mirror()->constant_encoding());
eab84554e829 src/hotspot/share/opto/output.cpp    (Wang Huang          2021-04-07 10:48:17 +0000 1115)           ObjectValue* sv = spobj->is_auto_box() ? new AutoBoxObjectValue(spobj->_idx, klass_sv)
eab84554e829 src/hotspot/share/opto/output.cpp    (Wang Huang          2021-04-07 10:48:17 +0000 1116)                                         : new ObjectValue(spobj->_idx, klass_sv);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1117)           PhaseOutput::set_sv_for_object_node(objs, sv);
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700 1118) 
ccfb92c6a964 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2013-08-23 11:41:37 -0700 1119)           uint first_ind = spobj->first_index(youngest_jvms);
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700 1120)           for (uint i = 0; i < spobj->n_fields(); i++) {
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700 1121)             Node* fld_node = sfn->in(first_ind+i);
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700 1122)             (void)FillLocArray(sv->field_values()->length(), sfn, fld_node, sv->field_values(), objs);
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700 1123)           }
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700 1124)           scval = sv;
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700 1125)         }
ccfb92c6a964 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2013-08-23 11:41:37 -0700 1126)       } else if (!obj_node->is_Con()) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1127)         OptoReg::Name obj_reg = C->regalloc()->get_reg_first(obj_node);
659ca734bb71 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-09-10 18:23:32 -0700 1128)         if( obj_node->bottom_type()->base() == Type::NarrowOop ) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1129)           scval = new_loc_value( C->regalloc(), obj_reg, Location::narrowoop );
659ca734bb71 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-09-10 18:23:32 -0700 1130)         } else {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1131)           scval = new_loc_value( C->regalloc(), obj_reg, Location::oop );
659ca734bb71 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-09-10 18:23:32 -0700 1132)         }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1133)       } else {
d7176bf7f878 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2013-05-09 17:28:04 -0700 1134)         const TypePtr *tp = obj_node->get_ptr_type();
69bcf415400f hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-05-24 12:54:51 -0700 1135)         scval = new ConstantOopWriteValue(tp->is_oopptr()->const_oop()->constant_encoding());
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1136)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1137) 
94927c382b40 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2012-01-07 13:26:43 -0800 1138)       OptoReg::Name box_reg = BoxLockNode::reg(box_node);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1139)       Location basic_lock = Location::new_stk_loc(Location::normal,C->regalloc()->reg2offset(box_reg));
94927c382b40 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2012-01-07 13:26:43 -0800 1140)       bool eliminated = (box_node->is_BoxLock() && box_node->as_BoxLock()->is_eliminated());
94927c382b40 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2012-01-07 13:26:43 -0800 1141)       monarray->append(new MonitorValue(scval, basic_lock, eliminated));
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1142)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1143) 
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700 1144)     // We dump the object pool first, since deoptimization reads it in first.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1145)     C->debug_info()->dump_object_pool(objs);
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700 1146) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1147)     // Build first class objects to pass to scope
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1148)     DebugToken *locvals = C->debug_info()->create_scope_values(locarray);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1149)     DebugToken *expvals = C->debug_info()->create_scope_values(exparray);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1150)     DebugToken *monvals = C->debug_info()->create_monitor_values(monarray);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1151) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1152)     // Make method available for all Safepoints
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1153)     ciMethod* scope_method = method ? method : C->method();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1154)     // Describe the scope here
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1155)     assert(jvms->bci() >= InvocationEntryBci && jvms->bci() <= 0x10000, "must be a valid or entry BCI");
caf28727ebe6 hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-01-04 18:38:08 +0100 1156)     assert(!jvms->should_reexecute() || depth == max_depth, "reexecute allowed only for the youngest");
000ac830a034 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2008-03-13 16:06:34 -0700 1157)     // Now we can describe the scope.
16526e000e72 hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2015-10-08 12:49:30 -1000 1158)     methodHandle null_mh;
16526e000e72 hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2015-10-08 12:49:30 -1000 1159)     bool rethrow_exception = false;
0fb31dbf3a2a src/hotspot/share/opto/output.cpp    (Maurizio Cimadamore 2020-11-23 11:00:38 +0000 1160)     C->debug_info()->describe_scope(
0fb31dbf3a2a src/hotspot/share/opto/output.cpp    (Maurizio Cimadamore 2020-11-23 11:00:38 +0000 1161)       safepoint_pc_offset,
0fb31dbf3a2a src/hotspot/share/opto/output.cpp    (Maurizio Cimadamore 2020-11-23 11:00:38 +0000 1162)       null_mh,
0fb31dbf3a2a src/hotspot/share/opto/output.cpp    (Maurizio Cimadamore 2020-11-23 11:00:38 +0000 1163)       scope_method,
0fb31dbf3a2a src/hotspot/share/opto/output.cpp    (Maurizio Cimadamore 2020-11-23 11:00:38 +0000 1164)       jvms->bci(),
0fb31dbf3a2a src/hotspot/share/opto/output.cpp    (Maurizio Cimadamore 2020-11-23 11:00:38 +0000 1165)       jvms->should_reexecute(),
0fb31dbf3a2a src/hotspot/share/opto/output.cpp    (Maurizio Cimadamore 2020-11-23 11:00:38 +0000 1166)       rethrow_exception,
0fb31dbf3a2a src/hotspot/share/opto/output.cpp    (Maurizio Cimadamore 2020-11-23 11:00:38 +0000 1167)       is_method_handle_invoke,
0fb31dbf3a2a src/hotspot/share/opto/output.cpp    (Maurizio Cimadamore 2020-11-23 11:00:38 +0000 1168)       is_opt_native,
0fb31dbf3a2a src/hotspot/share/opto/output.cpp    (Maurizio Cimadamore 2020-11-23 11:00:38 +0000 1169)       return_oop,
0fb31dbf3a2a src/hotspot/share/opto/output.cpp    (Maurizio Cimadamore 2020-11-23 11:00:38 +0000 1170)       has_ea_local_in_scope,
0fb31dbf3a2a src/hotspot/share/opto/output.cpp    (Maurizio Cimadamore 2020-11-23 11:00:38 +0000 1171)       arg_escape,
0fb31dbf3a2a src/hotspot/share/opto/output.cpp    (Maurizio Cimadamore 2020-11-23 11:00:38 +0000 1172)       locvals,
0fb31dbf3a2a src/hotspot/share/opto/output.cpp    (Maurizio Cimadamore 2020-11-23 11:00:38 +0000 1173)       expvals,
0fb31dbf3a2a src/hotspot/share/opto/output.cpp    (Maurizio Cimadamore 2020-11-23 11:00:38 +0000 1174)       monvals
0fb31dbf3a2a src/hotspot/share/opto/output.cpp    (Maurizio Cimadamore 2020-11-23 11:00:38 +0000 1175)     );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1176)   } // End jvms loop
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1177) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1178)   // Mark the end of the scope set.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1179)   C->debug_info()->end_safepoint(safepoint_pc_offset);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1180) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1181) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1182) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1183) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1184) // A simplified version of Process_OopMap_Node, to handle non-safepoints.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1185) class NonSafepointEmitter {
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1186)     Compile*  C;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1187)     JVMState* _pending_jvms;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1188)     int       _pending_offset;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1189) 
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1190)     void emit_non_safepoint();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1191) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1192)  public:
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1193)     NonSafepointEmitter(Compile* compile) {
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1194)       this->C = compile;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1195)       _pending_jvms = NULL;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1196)       _pending_offset = 0;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1197)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1198) 
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1199)     void observe_instruction(Node* n, int pc_offset) {
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1200)       if (!C->debug_info()->recording_non_safepoints())  return;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1201) 
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1202)       Node_Notes* nn = C->node_notes_at(n->_idx);
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1203)       if (nn == NULL || nn->jvms() == NULL)  return;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1204)       if (_pending_jvms != NULL &&
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1205)           _pending_jvms->same_calls_as(nn->jvms())) {
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1206)         // Repeated JVMS?  Stretch it up here.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1207)         _pending_offset = pc_offset;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1208)       } else {
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1209)         if (_pending_jvms != NULL &&
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1210)             _pending_offset < pc_offset) {
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1211)           emit_non_safepoint();
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1212)         }
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1213)         _pending_jvms = NULL;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1214)         if (pc_offset > C->debug_info()->last_pc_offset()) {
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1215)           // This is the only way _pending_jvms can become non-NULL:
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1216)           _pending_jvms = nn->jvms();
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1217)           _pending_offset = pc_offset;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1218)         }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1219)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1220)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1221) 
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1222)     // Stay out of the way of real safepoints:
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1223)     void observe_safepoint(JVMState* jvms, int pc_offset) {
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1224)       if (_pending_jvms != NULL &&
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1225)           !_pending_jvms->same_calls_as(jvms) &&
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1226)           _pending_offset < pc_offset) {
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1227)         emit_non_safepoint();
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1228)       }
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1229)       _pending_jvms = NULL;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1230)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1231) 
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1232)     void flush_at_end() {
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1233)       if (_pending_jvms != NULL) {
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1234)         emit_non_safepoint();
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1235)       }
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1236)       _pending_jvms = NULL;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1237)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1238) };
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1239) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1240) void NonSafepointEmitter::emit_non_safepoint() {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1241)   JVMState* youngest_jvms = _pending_jvms;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1242)   int       pc_offset     = _pending_offset;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1243) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1244)   // Clear it now:
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1245)   _pending_jvms = NULL;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1246) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1247)   DebugInformationRecorder* debug_info = C->debug_info();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1248)   assert(debug_info->recording_non_safepoints(), "sanity");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1249) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1250)   debug_info->add_non_safepoint(pc_offset);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1251)   int max_depth = youngest_jvms->depth();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1252) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1253)   // Visit scopes from oldest to youngest.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1254)   for (int depth = 1; depth <= max_depth; depth++) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1255)     JVMState* jvms = youngest_jvms->of_depth(depth);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1256)     ciMethod* method = jvms->has_method() ? jvms->method() : NULL;
ae00753bf79f hotspot/src/share/vm/opto/output.cpp (Changpeng Fang      2009-07-31 17:12:33 -0700 1257)     assert(!jvms->should_reexecute() || depth==max_depth, "reexecute allowed only for the youngest");
16526e000e72 hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2015-10-08 12:49:30 -1000 1258)     methodHandle null_mh;
16526e000e72 hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2015-10-08 12:49:30 -1000 1259)     debug_info->describe_scope(pc_offset, null_mh, method, jvms->bci(), jvms->should_reexecute());
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1260)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1261) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1262)   // Mark the end of the scope set.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1263)   debug_info->end_non_safepoint(pc_offset);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1264) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1265) 
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1266) //------------------------------init_buffer------------------------------------
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1267) void PhaseOutput::estimate_buffer_size(int& const_req) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1268) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1269)   // Set the initially allocated size
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1270)   const_req = initial_const_capacity;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1271) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1272)   // The extra spacing after the code is necessary on some platforms.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1273)   // Sometimes we need to patch in a jump after the last instruction,
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1274)   // if the nmethod has been deoptimized.  (See 4932387, 4894843.)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1275) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1276)   // Compute the byte offset where we can store the deopt pc.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1277)   if (C->fixed_slots() != 0) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1278)     _orig_pc_slot_offset_in_bytes = C->regalloc()->reg2offset(OptoReg::stack2reg(_orig_pc_slot));
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1279)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1280) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1281)   // Compute prolog code size
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1282)   _method_size = 0;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1283)   _frame_slots = OptoReg::reg2stack(C->matcher()->_old_SP) + C->regalloc()->_framesize;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1284)   assert(_frame_slots >= 0 && _frame_slots < 1000000, "sanity check");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1285) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1286)   if (C->has_mach_constant_base_node()) {
d22bde2c913e hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2013-11-20 11:08:09 -0800 1287)     uint add_size = 0;
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800 1288)     // Fill the constant table.
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1289)     // Note:  This must happen before shorten_branches.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1290)     for (uint i = 0; i < C->cfg()->number_of_blocks(); i++) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1291)       Block* b = C->cfg()->get_block(i);
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800 1292) 
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 1293)       for (uint j = 0; j < b->number_of_nodes(); j++) {
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 1294)         Node* n = b->get_node(j);
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800 1295) 
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800 1296)         // If the node is a MachConstantNode evaluate the constant
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800 1297)         // value section.
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800 1298)         if (n->is_MachConstant()) {
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800 1299)           MachConstantNode* machcon = n->as_MachConstant();
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800 1300)           machcon->eval_constant(C);
d22bde2c913e hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2013-11-20 11:08:09 -0800 1301)         } else if (n->is_Mach()) {
d22bde2c913e hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2013-11-20 11:08:09 -0800 1302)           // On Power there are more nodes that issue constants.
d22bde2c913e hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2013-11-20 11:08:09 -0800 1303)           add_size += (n->as_Mach()->ins_num_consts() * 8);
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800 1304)         }
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800 1305)       }
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800 1306)     }
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800 1307) 
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800 1308)     // Calculate the offsets of the constants and the size of the
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800 1309)     // constant table (including the padding to the next section).
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800 1310)     constant_table().calculate_offsets_and_size();
d22bde2c913e hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2013-11-20 11:08:09 -0800 1311)     const_req = constant_table().size() + add_size;
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800 1312)   }
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800 1313) 
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800 1314)   // Initialize the space for the BufferBlob used to find and verify
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800 1315)   // instruction size in MachNode::emit_size()
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800 1316)   init_scratch_buffer_blob(const_req);
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1317) }
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800 1318) 
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000 1319) CodeBuffer* PhaseOutput::init_buffer() {
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000 1320)   int stub_req  = _buf_sizes._stub;
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000 1321)   int code_req  = _buf_sizes._code;
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000 1322)   int const_req = _buf_sizes._const;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1323) 
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1324)   int pad_req   = NativeCall::instruction_size;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1325) 
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1326)   BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1327)   stub_req += bs->estimate_stub_size();
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000 1328)   stub_req += safepoint_poll_table()->estimate_stub_size();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1329) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1330)   // nmethod and CodeBuffer count stubs & constants as part of method's code.
ac75d4fc2fb3 hotspot/src/share/vm/opto/output.cpp (Lutz Schmidt        2014-03-25 12:54:21 -0700 1331)   // class HandlerImpl is platform-specific and defined in the *.ad files.
ac75d4fc2fb3 hotspot/src/share/vm/opto/output.cpp (Lutz Schmidt        2014-03-25 12:54:21 -0700 1332)   int exception_handler_req = HandlerImpl::size_exception_handler() + MAX_stubs_size; // add marginal slop for handler
ac75d4fc2fb3 hotspot/src/share/vm/opto/output.cpp (Lutz Schmidt        2014-03-25 12:54:21 -0700 1333)   int deopt_handler_req     = HandlerImpl::size_deopt_handler()     + MAX_stubs_size; // add marginal slop for handler
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1334)   stub_req += MAX_stubs_size;   // ensure per-stub margin
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1335)   code_req += MAX_inst_size;    // ensure per-instruction margin
0c605ed991d7 hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-02-18 11:35:41 +0100 1336) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1337)   if (StressCodeBuffers)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1338)     code_req = const_req = stub_req = exception_handler_req = deopt_handler_req = 0x10;  // force expansion
0c605ed991d7 hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-02-18 11:35:41 +0100 1339) 
0c605ed991d7 hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-02-18 11:35:41 +0100 1340)   int total_req =
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1341)           const_req +
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1342)           code_req +
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1343)           pad_req +
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1344)           stub_req +
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1345)           exception_handler_req +
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1346)           deopt_handler_req;               // deopt handler
0c605ed991d7 hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-02-18 11:35:41 +0100 1347) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1348)   if (C->has_method_handle_invokes())
0c605ed991d7 hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-02-18 11:35:41 +0100 1349)     total_req += deopt_handler_req;  // deopt MH handler
0c605ed991d7 hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-02-18 11:35:41 +0100 1350) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1351)   CodeBuffer* cb = code_buffer();
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000 1352)   cb->initialize(total_req, _buf_sizes._reloc);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1353) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1354)   // Have we run out of code space?
a57d68e35b2c hotspot/src/share/vm/opto/output.cpp (Eric Caspole        2010-01-29 09:27:22 -0800 1355)   if ((cb->blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
92ef5fe748ef hotspot/src/share/vm/opto/output.cpp (Nils Eliasson       2013-04-11 13:57:44 +0200 1356)     C->record_failure("CodeCache is full");
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1357)     return NULL;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1358)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1359)   // Configure the code buffer.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1360)   cb->initialize_consts_size(const_req);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1361)   cb->initialize_stubs_size(stub_req);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1362)   cb->initialize_oop_recorder(C->env()->oop_recorder());
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1363) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1364)   // fill in the nop array for bundling computations
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1365)   MachNode *_nop_list[Bundle::_nop_count];
70a55eac34c6 hotspot/src/share/vm/opto/output.cpp (Tobias Hartmann     2014-08-05 09:58:52 +0200 1366)   Bundle::initialize_nops(_nop_list);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1367) 
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1368)   return cb;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1369) }
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1370) 
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1371) //------------------------------fill_buffer------------------------------------
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1372) void PhaseOutput::fill_buffer(CodeBuffer* cb, uint* blk_starts) {
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1373)   // blk_starts[] contains offsets calculated during short branches processing,
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1374)   // offsets should not be increased during following steps.
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1375) 
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1376)   // Compute the size of first NumberOfLoopInstrToAlign instructions at head
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1377)   // of a loop. It is used to determine the padding for loop alignment.
38d690b3c347 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-05-19 17:51:02 +0000 1378)   Compile::TracePhase tp("fill buffer", &timers[_t_fillBuffer]);
38d690b3c347 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-05-19 17:51:02 +0000 1379) 
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1380)   compute_loop_first_inst_sizes();
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1381) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1382)   // Create oopmap set.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1383)   _oop_map_set = new OopMapSet();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1384) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1385)   // !!!!! This preserves old handling of oopmaps for now
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1386)   C->debug_info()->set_oopmaps(_oop_map_set);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1387) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1388)   uint nblocks  = C->cfg()->number_of_blocks();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1389)   // Count and start of implicit null check instructions
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1390)   uint inct_cnt = 0;
f279ddfa0639 src/hotspot/share/opto/output.cpp    (Patric Hedlin       2020-10-22 15:56:56 +0000 1391)   uint* inct_starts = NEW_RESOURCE_ARRAY(uint, nblocks+1);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1392) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1393)   // Count and start of calls
f279ddfa0639 src/hotspot/share/opto/output.cpp    (Patric Hedlin       2020-10-22 15:56:56 +0000 1394)   uint* call_returns = NEW_RESOURCE_ARRAY(uint, nblocks+1);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1395) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1396)   uint  return_offset = 0;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1397)   int nop_size = (new MachNopNode())->size(C->regalloc());
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1398) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1399)   int previous_offset = 0;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1400)   int current_offset  = 0;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1401)   int last_call_offset = -1;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1402)   int last_avoid_back_to_back_offset = -1;
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1403) #ifdef ASSERT
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1404)   uint* jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks);
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1405)   uint* jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1406)   uint* jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1407)   uint* jmp_rule   = NEW_RESOURCE_ARRAY(uint,nblocks);
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1408) #endif
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1409) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1410)   // Create an array of unused labels, one for each basic block, if printing is enabled
b73080515969 src/hotspot/share/opto/output.cpp    (Lutz Schmidt        2019-05-21 15:51:35 +0200 1411) #if defined(SUPPORT_OPTO_ASSEMBLY)
f279ddfa0639 src/hotspot/share/opto/output.cpp    (Patric Hedlin       2020-10-22 15:56:56 +0000 1412)   int* node_offsets      = NULL;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1413)   uint node_offset_limit = C->unique();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1414) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1415)   if (C->print_assembly()) {
b73080515969 src/hotspot/share/opto/output.cpp    (Lutz Schmidt        2019-05-21 15:51:35 +0200 1416)     node_offsets = NEW_RESOURCE_ARRAY(int, node_offset_limit);
b73080515969 src/hotspot/share/opto/output.cpp    (Lutz Schmidt        2019-05-21 15:51:35 +0200 1417)   }
b73080515969 src/hotspot/share/opto/output.cpp    (Lutz Schmidt        2019-05-21 15:51:35 +0200 1418)   if (node_offsets != NULL) {
b73080515969 src/hotspot/share/opto/output.cpp    (Lutz Schmidt        2019-05-21 15:51:35 +0200 1419)     // We need to initialize. Unused array elements may contain garbage and mess up PrintOptoAssembly.
b73080515969 src/hotspot/share/opto/output.cpp    (Lutz Schmidt        2019-05-21 15:51:35 +0200 1420)     memset(node_offsets, 0, node_offset_limit*sizeof(int));
b73080515969 src/hotspot/share/opto/output.cpp    (Lutz Schmidt        2019-05-21 15:51:35 +0200 1421)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1422) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1423) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1424)   NonSafepointEmitter non_safepoints(C);  // emit non-safepoints lazily
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1425) 
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800 1426)   // Emit the constant table.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1427)   if (C->has_mach_constant_base_node()) {
8e42efaadac2 src/hotspot/share/opto/output.cpp    (Christian Hagedorn  2020-12-21 08:06:48 +0000 1428)     if (!constant_table().emit(*cb)) {
8e42efaadac2 src/hotspot/share/opto/output.cpp    (Christian Hagedorn  2020-12-21 08:06:48 +0000 1429)       C->record_failure("consts section overflow");
8e42efaadac2 src/hotspot/share/opto/output.cpp    (Christian Hagedorn  2020-12-21 08:06:48 +0000 1430)       return;
8e42efaadac2 src/hotspot/share/opto/output.cpp    (Christian Hagedorn  2020-12-21 08:06:48 +0000 1431)     }
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800 1432)   }
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800 1433) 
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1434)   // Create an array of labels, one for each basic block
f279ddfa0639 src/hotspot/share/opto/output.cpp    (Patric Hedlin       2020-10-22 15:56:56 +0000 1435)   Label* blk_labels = NEW_RESOURCE_ARRAY(Label, nblocks+1);
f279ddfa0639 src/hotspot/share/opto/output.cpp    (Patric Hedlin       2020-10-22 15:56:56 +0000 1436)   for (uint i = 0; i <= nblocks; i++) {
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1437)     blk_labels[i].init();
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1438)   }
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1439) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1440)   // Now fill in the code buffer
f279ddfa0639 src/hotspot/share/opto/output.cpp    (Patric Hedlin       2020-10-22 15:56:56 +0000 1441)   Node* delay_slot = NULL;
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1442)   for (uint i = 0; i < nblocks; i++) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1443)     Block* block = C->cfg()->get_block(i);
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000 1444)     _block = block;
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1445)     Node* head = block->head();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1446) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1447)     // If this block needs to start aligned (i.e, can be reached other
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1448)     // than by falling-thru from the previous block), then force the
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1449)     // start of a new bundle.
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1450)     if (Pipeline::requires_bundling() && starts_bundle(head)) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1451)       cb->flush_bundle(true);
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1452)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1453) 
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1454) #ifdef ASSERT
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1455)     if (!block->is_connector()) {
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1456)       stringStream st;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1457)       block->dump_head(C->cfg(), &st);
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1458)       MacroAssembler(cb).block_comment(st.as_string());
ffaadcecea2b hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-12-03 01:34:31 -0800 1459)     }
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1460)     jmp_target[i] = 0;
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1461)     jmp_offset[i] = 0;
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1462)     jmp_size[i]   = 0;
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1463)     jmp_rule[i]   = 0;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1464) #endif
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1465)     int blk_offset = current_offset;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1466) 
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1467)     // Define the label at the beginning of the basic block
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1468)     MacroAssembler(cb).bind(blk_labels[block->_pre_order]);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1469) 
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 1470)     uint last_inst = block->number_of_nodes();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1471) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1472)     // Emit block normally, except for last instruction.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1473)     // Emit means "dump code bits into code buffer".
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1474)     for (uint j = 0; j<last_inst; j++) {
76a8557d0cf0 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-04-08 15:34:56 +0000 1475)       _index = j;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1476) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1477)       // Get the node
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 1478)       Node* n = block->get_node(j);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1479) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1480)       // See if delay slots are supported
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1481)       if (valid_bundle_info(n) && node_bundling(n)->used_in_unconditional_delay()) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1482)         assert(delay_slot == NULL, "no use of delay slot node");
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1483)         assert(n->size(C->regalloc()) == Pipeline::instr_unit_size(), "delay slot instruction wrong size");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1484) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1485)         delay_slot = n;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1486)         continue;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1487)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1488) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1489)       // If this starts a new instruction group, then flush the current one
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1490)       // (but allow split bundles)
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1491)       if (Pipeline::requires_bundling() && starts_bundle(n))
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1492)         cb->flush_bundle(false);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1493) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1494)       // Special handling for SafePoint/Call Nodes
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1495)       bool is_mcall = false;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1496)       if (n->is_Mach()) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1497)         MachNode *mach = n->as_Mach();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1498)         is_mcall = n->is_MachCall();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1499)         bool is_sfn = n->is_MachSafePoint();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1500) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1501)         // If this requires all previous instructions be flushed, then do so
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1502)         if (is_sfn || is_mcall || mach->alignment_required() != 1) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1503)           cb->flush_bundle(true);
a4b2fe3b1c4e hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-08-25 05:27:54 -0700 1504)           current_offset = cb->insts_size();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1505)         }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1506) 
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1507)         // A padding may be needed again since a previous instruction
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1508)         // could be moved to delay slot.
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1509) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1510)         // align the instruction if necessary
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1511)         int padding = mach->compute_padding(current_offset);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1512)         // Make sure safepoint node for polling is distinct from a call's
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1513)         // return by adding a nop if needed.
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1514)         if (is_sfn && !is_mcall && padding == 0 && current_offset == last_call_offset) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1515)           padding = nop_size;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1516)         }
e6456ff2a4ef hotspot/src/share/vm/opto/output.cpp (Igor Veresov        2014-04-10 23:15:13 -0700 1517)         if (padding == 0 && mach->avoid_back_to_back(MachNode::AVOID_BEFORE) &&
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1518)             current_offset == last_avoid_back_to_back_offset) {
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1519)           // Avoid back to back some instructions.
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1520)           padding = nop_size;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1521)         }
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1522) 
da8430daf140 hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2016-09-22 18:29:15 +0200 1523)         if (padding > 0) {
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1524)           assert((padding % nop_size) == 0, "padding is not a multiple of NOP size");
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1525)           int nops_cnt = padding / nop_size;
2a0815a55e21 hotspot/src/share/vm/opto/output.cpp (Tobias Hartmann     2014-06-02 08:07:29 +0200 1526)           MachNode *nop = new MachNopNode(nops_cnt);
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 1527)           block->insert_node(nop, j++);
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1528)           last_inst++;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1529)           C->cfg()->map_node_to_block(nop, block);
da8430daf140 hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2016-09-22 18:29:15 +0200 1530)           // Ensure enough space.
da8430daf140 hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2016-09-22 18:29:15 +0200 1531)           cb->insts()->maybe_expand_to_ensure_remaining(MAX_inst_size);
da8430daf140 hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2016-09-22 18:29:15 +0200 1532)           if ((cb->blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
da8430daf140 hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2016-09-22 18:29:15 +0200 1533)             C->record_failure("CodeCache is full");
da8430daf140 hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2016-09-22 18:29:15 +0200 1534)             return;
da8430daf140 hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2016-09-22 18:29:15 +0200 1535)           }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1536)           nop->emit(*cb, C->regalloc());
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1537)           cb->flush_bundle(true);
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1538)           current_offset = cb->insts_size();
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1539)         }
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1540) 
0fb31dbf3a2a src/hotspot/share/opto/output.cpp    (Maurizio Cimadamore 2020-11-23 11:00:38 +0000 1541)         bool observe_safepoint = is_sfn;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1542)         // Remember the start of the last call in a basic block
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1543)         if (is_mcall) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1544)           MachCallNode *mcall = mach->as_MachCall();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1545) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1546)           // This destination address is NOT PC-relative
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1547)           mcall->method_set((intptr_t)mcall->entry_point());
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1548) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1549)           // Save the return address
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1550)           call_returns[block->_pre_order] = current_offset + mcall->ret_addr_offset();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1551) 
0fb31dbf3a2a src/hotspot/share/opto/output.cpp    (Maurizio Cimadamore 2020-11-23 11:00:38 +0000 1552)           observe_safepoint = mcall->guaranteed_safepoint();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1553)         }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1554) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1555)         // sfn will be valid whenever mcall is valid now because of inheritance
0fb31dbf3a2a src/hotspot/share/opto/output.cpp    (Maurizio Cimadamore 2020-11-23 11:00:38 +0000 1556)         if (observe_safepoint) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1557)           // Handle special safepoint nodes for synchronization
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1558)           if (!is_mcall) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1559)             MachSafePointNode *sfn = mach->as_MachSafePoint();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1560)             // !!!!! Stubs only need an oopmap right now, so bail out
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1561)             if (sfn->jvms()->method() == NULL) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1562)               // Write the oopmap directly to the code blob??!!
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1563)               continue;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1564)             }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1565)           } // End synchronization
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1566) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1567)           non_safepoints.observe_safepoint(mach->as_MachSafePoint()->jvms(),
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1568)                                            current_offset);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1569)           Process_OopMap_Node(mach, current_offset);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1570)         } // End if safepoint
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1571) 
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1572)           // If this is a null check, then add the start of the previous instruction to the list
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1573)         else if( mach->is_MachNullCheck() ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1574)           inct_starts[inct_cnt++] = previous_offset;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1575)         }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1576) 
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1577)           // If this is a branch, then fill in the label with the target BB's label
080f790edc7f hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-16 11:53:57 -0700 1578)         else if (mach->is_MachBranch()) {
080f790edc7f hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-16 11:53:57 -0700 1579)           // This requires the TRUE branch target be in succs[0]
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1580)           uint block_num = block->non_connector_successor(0)->_pre_order;
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1581) 
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1582)           // Try to replace long branch if delay slot is not used,
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1583)           // it is mostly for back branches since forward branch's
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1584)           // distance is not updated yet.
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1585)           bool delay_slot_is_used = valid_bundle_info(n) &&
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1586)                                     C->output()->node_bundling(n)->use_unconditional_delay();
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1587)           if (!delay_slot_is_used && mach->may_be_short_branch()) {
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1588)             assert(delay_slot == NULL, "not expecting delay slot node");
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1589)             int br_size = n->size(C->regalloc());
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1590)             int offset = blk_starts[block_num] - current_offset;
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1591)             if (block_num >= i) {
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1592)               // Current and following block's offset are not
d22bde2c913e hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2013-11-20 11:08:09 -0800 1593)               // finalized yet, adjust distance by the difference
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1594)               // between calculated and final offsets of current block.
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1595)               offset -= (blk_starts[i] - blk_offset);
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1596)             }
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1597)             // In the following code a nop could be inserted before
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1598)             // the branch which will increase the backward distance.
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1599)             bool needs_padding = (current_offset == last_avoid_back_to_back_offset);
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1600)             if (needs_padding && offset <= 0)
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1601)               offset -= nop_size;
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1602) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1603)             if (C->matcher()->is_short_branch_offset(mach->rule(), br_size, offset)) {
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1604)               // We've got a winner.  Replace this branch.
70a55eac34c6 hotspot/src/share/vm/opto/output.cpp (Tobias Hartmann     2014-08-05 09:58:52 +0200 1605)               MachNode* replacement = mach->as_MachBranch()->short_branch_version();
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1606) 
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1607)               // Update the jmp_size.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1608)               int new_size = replacement->size(C->regalloc());
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1609)               assert((br_size - new_size) >= (int)nop_size, "short_branch size should be smaller");
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1610)               // Insert padding between avoid_back_to_back branches.
e6456ff2a4ef hotspot/src/share/vm/opto/output.cpp (Igor Veresov        2014-04-10 23:15:13 -0700 1611)               if (needs_padding && replacement->avoid_back_to_back(MachNode::AVOID_BEFORE)) {
2a0815a55e21 hotspot/src/share/vm/opto/output.cpp (Tobias Hartmann     2014-06-02 08:07:29 +0200 1612)                 MachNode *nop = new MachNopNode();
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 1613)                 block->insert_node(nop, j++);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1614)                 C->cfg()->map_node_to_block(nop, block);
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1615)                 last_inst++;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1616)                 nop->emit(*cb, C->regalloc());
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1617)                 cb->flush_bundle(true);
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1618)                 current_offset = cb->insts_size();
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1619)               }
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1620) #ifdef ASSERT
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1621)               jmp_target[i] = block_num;
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1622)               jmp_offset[i] = current_offset - blk_offset;
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1623)               jmp_size[i]   = new_size;
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1624)               jmp_rule[i]   = mach->rule();
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1625) #endif
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 1626)               block->map_node(replacement, j);
2d2532e74001 hotspot/src/share/vm/opto/output.cpp (Bharadwaj Yadavalli 2012-11-27 17:24:15 -0800 1627)               mach->subsume_by(replacement, C);
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1628)               n    = replacement;
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1629)               mach = replacement;
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1630)             }
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1631)           }
080f790edc7f hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-16 11:53:57 -0700 1632)           mach->as_MachBranch()->label_set( &blk_labels[block_num], block_num );
080f790edc7f hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-16 11:53:57 -0700 1633)         } else if (mach->ideal_Opcode() == Op_Jump) {
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1634)           for (uint h = 0; h < block->_num_succs; h++) {
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1635)             Block* succs_block = block->_succs[h];
080f790edc7f hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-16 11:53:57 -0700 1636)             for (uint j = 1; j < succs_block->num_preds(); j++) {
080f790edc7f hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-16 11:53:57 -0700 1637)               Node* jpn = succs_block->pred(j);
080f790edc7f hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-16 11:53:57 -0700 1638)               if (jpn->is_JumpProj() && jpn->in(0) == mach) {
080f790edc7f hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-16 11:53:57 -0700 1639)                 uint block_num = succs_block->non_connector()->_pre_order;
080f790edc7f hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-16 11:53:57 -0700 1640)                 Label *blkLabel = &blk_labels[block_num];
080f790edc7f hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-16 11:53:57 -0700 1641)                 mach->add_case_label(jpn->as_JumpProj()->proj_no(), blkLabel);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1642)               }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1643)             }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1644)           }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1645)         }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1646) #ifdef ASSERT
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1647)           // Check that oop-store precedes the card-mark
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1648)         else if (mach->ideal_Opcode() == Op_StoreCM) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1649)           uint storeCM_idx = j;
aac4647e6eb7 hotspot/src/share/vm/opto/output.cpp (Tom Rodriguez       2011-04-05 19:14:03 -0700 1650)           int count = 0;
aac4647e6eb7 hotspot/src/share/vm/opto/output.cpp (Tom Rodriguez       2011-04-05 19:14:03 -0700 1651)           for (uint prec = mach->req(); prec < mach->len(); prec++) {
aac4647e6eb7 hotspot/src/share/vm/opto/output.cpp (Tom Rodriguez       2011-04-05 19:14:03 -0700 1652)             Node *oop_store = mach->in(prec);  // Precedence edge
aac4647e6eb7 hotspot/src/share/vm/opto/output.cpp (Tom Rodriguez       2011-04-05 19:14:03 -0700 1653)             if (oop_store == NULL) continue;
aac4647e6eb7 hotspot/src/share/vm/opto/output.cpp (Tom Rodriguez       2011-04-05 19:14:03 -0700 1654)             count++;
aac4647e6eb7 hotspot/src/share/vm/opto/output.cpp (Tom Rodriguez       2011-04-05 19:14:03 -0700 1655)             uint i4;
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1656)             for (i4 = 0; i4 < last_inst; ++i4) {
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 1657)               if (block->get_node(i4) == oop_store) {
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1658)                 break;
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1659)               }
aac4647e6eb7 hotspot/src/share/vm/opto/output.cpp (Tom Rodriguez       2011-04-05 19:14:03 -0700 1660)             }
aac4647e6eb7 hotspot/src/share/vm/opto/output.cpp (Tom Rodriguez       2011-04-05 19:14:03 -0700 1661)             // Note: This test can provide a false failure if other precedence
aac4647e6eb7 hotspot/src/share/vm/opto/output.cpp (Tom Rodriguez       2011-04-05 19:14:03 -0700 1662)             // edges have been added to the storeCMNode.
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1663)             assert(i4 == last_inst || i4 < storeCM_idx, "CM card-mark executes before oop-store");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1664)           }
aac4647e6eb7 hotspot/src/share/vm/opto/output.cpp (Tom Rodriguez       2011-04-05 19:14:03 -0700 1665)           assert(count > 0, "storeCM expects at least one precedence edge");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1666)         }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1667) #endif
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1668)         else if (!n->is_Proj()) {
05d1de77274c hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2009-02-27 13:27:09 -0800 1669)           // Remember the beginning of the previous instruction, in case
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1670)           // it's followed by a flag-kill and a null-check.  Happens on
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1671)           // Intel all the time, with add-to-memory kind of opcodes.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1672)           previous_offset = current_offset;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1673)         }
ecca1bcc72e9 hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2013-11-27 16:16:21 -0800 1674) 
ecca1bcc72e9 hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2013-11-27 16:16:21 -0800 1675)         // Not an else-if!
ecca1bcc72e9 hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2013-11-27 16:16:21 -0800 1676)         // If this is a trap based cmp then add its offset to the list.
ecca1bcc72e9 hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2013-11-27 16:16:21 -0800 1677)         if (mach->is_TrapBasedCheckNode()) {
ecca1bcc72e9 hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2013-11-27 16:16:21 -0800 1678)           inct_starts[inct_cnt++] = current_offset;
ecca1bcc72e9 hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2013-11-27 16:16:21 -0800 1679)         }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1680)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1681) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1682)       // Verify that there is sufficient space remaining
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1683)       cb->insts()->maybe_expand_to_ensure_remaining(MAX_inst_size);
a57d68e35b2c hotspot/src/share/vm/opto/output.cpp (Eric Caspole        2010-01-29 09:27:22 -0800 1684)       if ((cb->blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
92ef5fe748ef hotspot/src/share/vm/opto/output.cpp (Nils Eliasson       2013-04-11 13:57:44 +0200 1685)         C->record_failure("CodeCache is full");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1686)         return;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1687)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1688) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1689)       // Save the offset for the listing
b73080515969 src/hotspot/share/opto/output.cpp    (Lutz Schmidt        2019-05-21 15:51:35 +0200 1690) #if defined(SUPPORT_OPTO_ASSEMBLY)
b73080515969 src/hotspot/share/opto/output.cpp    (Lutz Schmidt        2019-05-21 15:51:35 +0200 1691)       if ((node_offsets != NULL) && (n->_idx < node_offset_limit)) {
a4b2fe3b1c4e hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-08-25 05:27:54 -0700 1692)         node_offsets[n->_idx] = cb->insts_size();
b73080515969 src/hotspot/share/opto/output.cpp    (Lutz Schmidt        2019-05-21 15:51:35 +0200 1693)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1694) #endif
f279ddfa0639 src/hotspot/share/opto/output.cpp    (Patric Hedlin       2020-10-22 15:56:56 +0000 1695)       assert(!C->failing(), "Should not reach here if failing.");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1696) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1697)       // "Normal" instruction case
f279ddfa0639 src/hotspot/share/opto/output.cpp    (Patric Hedlin       2020-10-22 15:56:56 +0000 1698)       DEBUG_ONLY(uint instr_offset = cb->insts_size());
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1699)       n->emit(*cb, C->regalloc());
7467f0ba15c7 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2022-02-16 16:29:52 +0100 1700) 
f279ddfa0639 src/hotspot/share/opto/output.cpp    (Patric Hedlin       2020-10-22 15:56:56 +0000 1701)       current_offset = cb->insts_size();
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1702) 
e834a481000f hotspot/src/share/vm/opto/output.cpp (Tobias Hartmann     2015-07-29 08:05:21 +0200 1703)       // Above we only verified that there is enough space in the instruction section.
e834a481000f hotspot/src/share/vm/opto/output.cpp (Tobias Hartmann     2015-07-29 08:05:21 +0200 1704)       // However, the instruction may emit stubs that cause code buffer expansion.
e834a481000f hotspot/src/share/vm/opto/output.cpp (Tobias Hartmann     2015-07-29 08:05:21 +0200 1705)       // Bail out here if expansion failed due to a lack of code cache space.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1706)       if (C->failing()) {
e834a481000f hotspot/src/share/vm/opto/output.cpp (Tobias Hartmann     2015-07-29 08:05:21 +0200 1707)         return;
e834a481000f hotspot/src/share/vm/opto/output.cpp (Tobias Hartmann     2015-07-29 08:05:21 +0200 1708)       }
e834a481000f hotspot/src/share/vm/opto/output.cpp (Tobias Hartmann     2015-07-29 08:05:21 +0200 1709) 
e3d0f270314f src/hotspot/share/opto/output.cpp    (Patric Hedlin       2020-12-01 14:16:41 +0000 1710)       assert(!is_mcall || (call_returns[block->_pre_order] <= (uint)current_offset),
e3d0f270314f src/hotspot/share/opto/output.cpp    (Patric Hedlin       2020-12-01 14:16:41 +0000 1711)              "ret_addr_offset() not within emitted code");
e3d0f270314f src/hotspot/share/opto/output.cpp    (Patric Hedlin       2020-12-01 14:16:41 +0000 1712) 
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1713) #ifdef ASSERT
241f401815db src/hotspot/share/opto/output.cpp    (Vladimir Kozlov     2020-06-12 14:33:20 -0700 1714)       uint n_size = n->size(C->regalloc());
241f401815db src/hotspot/share/opto/output.cpp    (Vladimir Kozlov     2020-06-12 14:33:20 -0700 1715)       if (n_size < (current_offset-instr_offset)) {
241f401815db src/hotspot/share/opto/output.cpp    (Vladimir Kozlov     2020-06-12 14:33:20 -0700 1716)         MachNode* mach = n->as_Mach();
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1717)         n->dump();
241f401815db src/hotspot/share/opto/output.cpp    (Vladimir Kozlov     2020-06-12 14:33:20 -0700 1718)         mach->dump_format(C->regalloc(), tty);
241f401815db src/hotspot/share/opto/output.cpp    (Vladimir Kozlov     2020-06-12 14:33:20 -0700 1719)         tty->print_cr(" n_size (%d), current_offset (%d), instr_offset (%d)", n_size, current_offset, instr_offset);
241f401815db src/hotspot/share/opto/output.cpp    (Vladimir Kozlov     2020-06-12 14:33:20 -0700 1720)         Disassembler::decode(cb->insts_begin() + instr_offset, cb->insts_begin() + current_offset + 1, tty);
241f401815db src/hotspot/share/opto/output.cpp    (Vladimir Kozlov     2020-06-12 14:33:20 -0700 1721)         tty->print_cr(" ------------------- ");
241f401815db src/hotspot/share/opto/output.cpp    (Vladimir Kozlov     2020-06-12 14:33:20 -0700 1722)         BufferBlob* blob = this->scratch_buffer_blob();
241f401815db src/hotspot/share/opto/output.cpp    (Vladimir Kozlov     2020-06-12 14:33:20 -0700 1723)         address blob_begin = blob->content_begin();
241f401815db src/hotspot/share/opto/output.cpp    (Vladimir Kozlov     2020-06-12 14:33:20 -0700 1724)         Disassembler::decode(blob_begin, blob_begin + n_size + 1, tty);
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1725)         assert(false, "wrong size of mach node");
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1726)       }
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1727) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1728)       non_safepoints.observe_instruction(n, current_offset);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1729) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1730)       // mcall is last "call" that can be a safepoint
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1731)       // record it so we can see if a poll will directly follow it
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1732)       // in which case we'll need a pad to make the PcDesc sites unique
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1733)       // see  5010568. This can be slightly inaccurate but conservative
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1734)       // in the case that return address is not actually at current_offset.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1735)       // This is a small price to pay.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1736) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1737)       if (is_mcall) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1738)         last_call_offset = current_offset;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1739)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1740) 
e6456ff2a4ef hotspot/src/share/vm/opto/output.cpp (Igor Veresov        2014-04-10 23:15:13 -0700 1741)       if (n->is_Mach() && n->as_Mach()->avoid_back_to_back(MachNode::AVOID_AFTER)) {
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1742)         // Avoid back to back some instructions.
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1743)         last_avoid_back_to_back_offset = current_offset;
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1744)       }
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1745) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1746)       // See if this instruction has a delay slot
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1747)       if (valid_bundle_info(n) && node_bundling(n)->use_unconditional_delay()) {
2e682fa3cd44 src/hotspot/share/opto/output.cpp    (Goetz Lindenmaier   2018-07-12 16:31:28 +0200 1748)         guarantee(delay_slot != NULL, "expecting delay slot node");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1749) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1750)         // Back up 1 instruction
a4b2fe3b1c4e hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-08-25 05:27:54 -0700 1751)         cb->set_insts_end(cb->insts_end() - Pipeline::instr_unit_size());
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1752) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1753)         // Save the offset for the listing
b73080515969 src/hotspot/share/opto/output.cpp    (Lutz Schmidt        2019-05-21 15:51:35 +0200 1754) #if defined(SUPPORT_OPTO_ASSEMBLY)
b73080515969 src/hotspot/share/opto/output.cpp    (Lutz Schmidt        2019-05-21 15:51:35 +0200 1755)         if ((node_offsets != NULL) && (delay_slot->_idx < node_offset_limit)) {
a4b2fe3b1c4e hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-08-25 05:27:54 -0700 1756)           node_offsets[delay_slot->_idx] = cb->insts_size();
b73080515969 src/hotspot/share/opto/output.cpp    (Lutz Schmidt        2019-05-21 15:51:35 +0200 1757)         }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1758) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1759) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1760)         // Support a SafePoint in the delay slot
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1761)         if (delay_slot->is_MachSafePoint()) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1762)           MachNode *mach = delay_slot->as_Mach();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1763)           // !!!!! Stubs only need an oopmap right now, so bail out
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 1764)           if (!mach->is_MachCall() && mach->as_MachSafePoint()->jvms()->method() == NULL) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1765)             // Write the oopmap directly to the code blob??!!
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1766)             delay_slot = NULL;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1767)             continue;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1768)           }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1769) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1770)           int adjusted_offset = current_offset - Pipeline::instr_unit_size();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1771)           non_safepoints.observe_safepoint(mach->as_MachSafePoint()->jvms(),
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1772)                                            adjusted_offset);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1773)           // Generate an OopMap entry
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1774)           Process_OopMap_Node(mach, adjusted_offset);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1775)         }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1776) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1777)         // Insert the delay slot instruction
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1778)         delay_slot->emit(*cb, C->regalloc());
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1779) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1780)         // Don't reuse it
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1781)         delay_slot = NULL;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1782)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1783) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1784)     } // End for all instructions in block
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1785) 
0e63b7609a2a hotspot/src/share/vm/opto/output.cpp (Chuck Rasbold       2008-11-06 14:59:10 -0800 1786)     // If the next block is the top of a loop, pad this block out to align
0e63b7609a2a hotspot/src/share/vm/opto/output.cpp (Chuck Rasbold       2008-11-06 14:59:10 -0800 1787)     // the loop top a little. Helps prevent pipe stalls at loop back branches.
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1788)     if (i < nblocks-1) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1789)       Block *nb = C->cfg()->get_block(i + 1);
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1790)       int padding = nb->alignment_padding(current_offset);
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1791)       if( padding > 0 ) {
2a0815a55e21 hotspot/src/share/vm/opto/output.cpp (Tobias Hartmann     2014-06-02 08:07:29 +0200 1792)         MachNode *nop = new MachNopNode(padding / nop_size);
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 1793)         block->insert_node(nop, block->number_of_nodes());
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1794)         C->cfg()->map_node_to_block(nop, block);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1795)         nop->emit(*cb, C->regalloc());
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1796)         current_offset = cb->insts_size();
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1797)       }
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1798)     }
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1799)     // Verify that the distance for generated before forward
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1800)     // short branches is still valid.
93c40233d6fa hotspot/src/share/vm/opto/output.cpp (Chuck Rasbold       2013-04-03 15:00:55 -0700 1801)     guarantee((int)(blk_starts[i+1] - blk_starts[i]) >= (current_offset - blk_offset), "shouldn't increase block size");
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1802) 
93c40233d6fa hotspot/src/share/vm/opto/output.cpp (Chuck Rasbold       2013-04-03 15:00:55 -0700 1803)     // Save new block start offset
93c40233d6fa hotspot/src/share/vm/opto/output.cpp (Chuck Rasbold       2013-04-03 15:00:55 -0700 1804)     blk_starts[i] = blk_offset;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1805)   } // End of for all blocks
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1806)   blk_starts[nblocks] = current_offset;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1807) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1808)   non_safepoints.flush_at_end();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1809) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1810)   // Offset too large?
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1811)   if (C->failing())  return;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1812) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1813)   // Define a pseudo-label at the end of the code
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1814)   MacroAssembler(cb).bind( blk_labels[nblocks] );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1815) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1816)   // Compute the size of the first block
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1817)   _first_block_size = blk_labels[1].loc_pos() - blk_labels[0].loc_pos();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1818) 
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1819) #ifdef ASSERT
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1820)   for (uint i = 0; i < nblocks; i++) { // For all blocks
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1821)     if (jmp_target[i] != 0) {
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1822)       int br_size = jmp_size[i];
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1823)       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1824)       if (!C->matcher()->is_short_branch_offset(jmp_rule[i], br_size, offset)) {
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1825)         tty->print_cr("target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d", blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1826)         assert(false, "Displacement too large for short jmp");
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1827)       }
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1828)     }
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1829)   }
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1830) #endif
ff4faaab4b81 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-18 11:49:33 -0700 1831) 
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1832)   BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1833)   bs->emit_stubs(*cb);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1834)   if (C->failing())  return;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 1835) 
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000 1836)   // Fill in stubs for calling the runtime from safepoint polls.
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000 1837)   safepoint_poll_table()->emit(*cb);
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000 1838)   if (C->failing())  return;
b9873e18330b src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-10-09 08:40:33 +0000 1839) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1840) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1841)   // Information on the size of the method, without the extraneous code
a4b2fe3b1c4e hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-08-25 05:27:54 -0700 1842)   Scheduling::increment_method_size(cb->insts_size());
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1843) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1844) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1845)   // ------------------
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1846)   // Fill in exception table entries.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1847)   FillExceptionTables(inct_cnt, call_returns, inct_starts, blk_labels);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1848) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1849)   // Only java methods have exception handlers and deopt handlers
ac75d4fc2fb3 hotspot/src/share/vm/opto/output.cpp (Lutz Schmidt        2014-03-25 12:54:21 -0700 1850)   // class HandlerImpl is platform-specific and defined in the *.ad files.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1851)   if (C->method()) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1852)     // Emit the exception handler code.
ac75d4fc2fb3 hotspot/src/share/vm/opto/output.cpp (Lutz Schmidt        2014-03-25 12:54:21 -0700 1853)     _code_offsets.set_value(CodeOffsets::Exceptions, HandlerImpl::emit_exception_handler(*cb));
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1854)     if (C->failing()) {
e834a481000f hotspot/src/share/vm/opto/output.cpp (Tobias Hartmann     2015-07-29 08:05:21 +0200 1855)       return; // CodeBuffer::expand failed
e834a481000f hotspot/src/share/vm/opto/output.cpp (Tobias Hartmann     2015-07-29 08:05:21 +0200 1856)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1857)     // Emit the deopt handler code.
ac75d4fc2fb3 hotspot/src/share/vm/opto/output.cpp (Lutz Schmidt        2014-03-25 12:54:21 -0700 1858)     _code_offsets.set_value(CodeOffsets::Deopt, HandlerImpl::emit_deopt_handler(*cb));
0c605ed991d7 hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-02-18 11:35:41 +0100 1859) 
0c605ed991d7 hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-02-18 11:35:41 +0100 1860)     // Emit the MethodHandle deopt handler code (if required).
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1861)     if (C->has_method_handle_invokes() && !C->failing()) {
0c605ed991d7 hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-02-18 11:35:41 +0100 1862)       // We can use the same code as for the normal deopt handler, we
0c605ed991d7 hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-02-18 11:35:41 +0100 1863)       // just need a different entry point address.
ac75d4fc2fb3 hotspot/src/share/vm/opto/output.cpp (Lutz Schmidt        2014-03-25 12:54:21 -0700 1864)       _code_offsets.set_value(CodeOffsets::DeoptMH, HandlerImpl::emit_deopt_handler(*cb));
0c605ed991d7 hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2010-02-18 11:35:41 +0100 1865)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1866)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1867) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1868)   // One last check for failed CodeBuffer::expand:
a57d68e35b2c hotspot/src/share/vm/opto/output.cpp (Eric Caspole        2010-01-29 09:27:22 -0800 1869)   if ((cb->blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
92ef5fe748ef hotspot/src/share/vm/opto/output.cpp (Nils Eliasson       2013-04-11 13:57:44 +0200 1870)     C->record_failure("CodeCache is full");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1871)     return;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1872)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1873) 
b73080515969 src/hotspot/share/opto/output.cpp    (Lutz Schmidt        2019-05-21 15:51:35 +0200 1874) #if defined(SUPPORT_ABSTRACT_ASSEMBLY) || defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_OPTO_ASSEMBLY)
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1875)   if (C->print_assembly()) {
b73080515969 src/hotspot/share/opto/output.cpp    (Lutz Schmidt        2019-05-21 15:51:35 +0200 1876)     tty->cr();
b73080515969 src/hotspot/share/opto/output.cpp    (Lutz Schmidt        2019-05-21 15:51:35 +0200 1877)     tty->print_cr("============================= C2-compiled nmethod ==============================");
b73080515969 src/hotspot/share/opto/output.cpp    (Lutz Schmidt        2019-05-21 15:51:35 +0200 1878)   }
b73080515969 src/hotspot/share/opto/output.cpp    (Lutz Schmidt        2019-05-21 15:51:35 +0200 1879) #endif
b73080515969 src/hotspot/share/opto/output.cpp    (Lutz Schmidt        2019-05-21 15:51:35 +0200 1880) 
b73080515969 src/hotspot/share/opto/output.cpp    (Lutz Schmidt        2019-05-21 15:51:35 +0200 1881) #if defined(SUPPORT_OPTO_ASSEMBLY)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1882)   // Dump the assembly code, including basic-block numbers
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1883)   if (C->print_assembly()) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1884)     ttyLocker ttyl;  // keep the following output all in one block
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1885)     if (!VMThread::should_terminate()) {  // test this under the tty lock
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1886)       // This output goes directly to the tty, not the compiler log.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1887)       // To enable tools to match it up with the compilation activity,
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1888)       // be sure to tag this tty output with the compile ID.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1889)       if (xtty != NULL) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1890)         xtty->head("opto_assembly compile_id='%d'%s", C->compile_id(),
f279ddfa0639 src/hotspot/share/opto/output.cpp    (Patric Hedlin       2020-10-22 15:56:56 +0000 1891)                    C->is_osr_compilation() ? " compile_kind='osr'" : "");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1892)       }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1893)       if (C->method() != NULL) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1894)         tty->print_cr("----------------------- MetaData before Compile_id = %d ------------------------", C->compile_id());
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1895)         C->method()->print_metadata();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1896)       } else if (C->stub_name() != NULL) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1897)         tty->print_cr("----------------------------- RuntimeStub %s -------------------------------", C->stub_name());
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1898)       }
b73080515969 src/hotspot/share/opto/output.cpp    (Lutz Schmidt        2019-05-21 15:51:35 +0200 1899)       tty->cr();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1900)       tty->print_cr("------------------------ OptoAssembly for Compile_id = %d -----------------------", C->compile_id());
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1901)       dump_asm(node_offsets, node_offset_limit);
b73080515969 src/hotspot/share/opto/output.cpp    (Lutz Schmidt        2019-05-21 15:51:35 +0200 1902)       tty->print_cr("--------------------------------------------------------------------------------");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1903)       if (xtty != NULL) {
24d3db305cb0 hotspot/src/share/vm/opto/output.cpp (Nils Eliasson       2016-04-22 16:05:00 +0200 1904)         // print_metadata and dump_asm above may safepoint which makes us loose the ttylock.
24d3db305cb0 hotspot/src/share/vm/opto/output.cpp (Nils Eliasson       2016-04-22 16:05:00 +0200 1905)         // Retake lock too make sure the end tag is coherent, and that xmlStream->pop_tag is done
24d3db305cb0 hotspot/src/share/vm/opto/output.cpp (Nils Eliasson       2016-04-22 16:05:00 +0200 1906)         // thread safe
24d3db305cb0 hotspot/src/share/vm/opto/output.cpp (Nils Eliasson       2016-04-22 16:05:00 +0200 1907)         ttyLocker ttyl2;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1908)         xtty->tail("opto_assembly");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1909)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1910)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1911)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1912) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1913) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1914) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1915) void PhaseOutput::FillExceptionTables(uint cnt, uint *call_returns, uint *inct_starts, Label *blk_labels) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1916)   _inc_table.set_size(cnt);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1917) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1918)   uint inct_cnt = 0;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1919)   for (uint i = 0; i < C->cfg()->number_of_blocks(); i++) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1920)     Block* block = C->cfg()->get_block(i);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1921)     Node *n = NULL;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1922)     int j;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1923) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1924)     // Find the branch; ignore trailing NOPs.
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 1925)     for (j = block->number_of_nodes() - 1; j >= 0; j--) {
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 1926)       n = block->get_node(j);
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1927)       if (!n->is_Mach() || n->as_Mach()->ideal_Opcode() != Op_Con) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1928)         break;
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1929)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1930)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1931) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1932)     // If we didn't find anything, continue
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1933)     if (j < 0) {
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1934)       continue;
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1935)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1936) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1937)     // Compute ExceptionHandlerTable subtable entry and add it
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1938)     // (skip empty blocks)
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1939)     if (n->is_Catch()) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1940) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1941)       // Get the offset of the return from the call
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1942)       uint call_return = call_returns[block->_pre_order];
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1943) #ifdef ASSERT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1944)       assert( call_return > 0, "no call seen for this basic block" );
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 1945)       while (block->get_node(--j)->is_MachProj()) ;
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 1946)       assert(block->get_node(j)->is_MachCall(), "CatchProj must follow call");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1947) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1948)       // last instruction is a CatchNode, find it's CatchProjNodes
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1949)       int nof_succs = block->_num_succs;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1950)       // allocate space
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1951)       GrowableArray<intptr_t> handler_bcis(nof_succs);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1952)       GrowableArray<intptr_t> handler_pcos(nof_succs);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1953)       // iterate through all successors
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1954)       for (int j = 0; j < nof_succs; j++) {
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1955)         Block* s = block->_succs[j];
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1956)         bool found_p = false;
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1957)         for (uint k = 1; k < s->num_preds(); k++) {
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1958)           Node* pk = s->pred(k);
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1959)           if (pk->is_CatchProj() && pk->in(0) == n) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1960)             const CatchProjNode* p = pk->as_CatchProj();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1961)             found_p = true;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1962)             // add the corresponding handler bci & pco information
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1963)             if (p->_con != CatchProjNode::fall_through_index) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1964)               // p leads to an exception handler (and is not fall through)
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 1965)               assert(s == C->cfg()->get_block(s->_pre_order), "bad numbering");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1966)               // no duplicates, please
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1967)               if (!handler_bcis.contains(p->handler_bci())) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1968)                 uint block_num = s->non_connector()->_pre_order;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1969)                 handler_bcis.append(p->handler_bci());
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1970)                 handler_pcos.append(blk_labels[block_num].loc_pos());
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1971)               }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1972)             }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1973)           }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1974)         }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1975)         assert(found_p, "no matching predecessor found");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1976)         // Note:  Due to empty block removal, one block may have
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1977)         // several CatchProj inputs, from the same Catch.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1978)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1979) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1980)       // Set the offset of the return from the call
b97f668af3f5 hotspot/src/share/vm/opto/output.cpp (Tom Rodriguez       2017-08-15 17:18:00 +0000 1981)       assert(handler_bcis.find(-1) != -1, "must have default handler");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1982)       _handler_table.add_subtable(call_return, &handler_bcis, NULL, &handler_pcos);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1983)       continue;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1984)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1985) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1986)     // Handle implicit null exception table updates
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1987)     if (n->is_MachNullCheck()) {
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1988)       uint block_num = block->non_connector_successor(0)->_pre_order;
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 1989)       _inc_table.append(inct_starts[inct_cnt++], blk_labels[block_num].loc_pos());
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1990)       continue;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1991)     }
ecca1bcc72e9 hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2013-11-27 16:16:21 -0800 1992)     // Handle implicit exception table updates: trap instructions.
ecca1bcc72e9 hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2013-11-27 16:16:21 -0800 1993)     if (n->is_Mach() && n->as_Mach()->is_TrapBasedCheckNode()) {
ecca1bcc72e9 hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2013-11-27 16:16:21 -0800 1994)       uint block_num = block->non_connector_successor(0)->_pre_order;
ecca1bcc72e9 hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2013-11-27 16:16:21 -0800 1995)       _inc_table.append(inct_starts[inct_cnt++], blk_labels[block_num].loc_pos());
ecca1bcc72e9 hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2013-11-27 16:16:21 -0800 1996)       continue;
ecca1bcc72e9 hotspot/src/share/vm/opto/output.cpp (Goetz Lindenmaier   2013-11-27 16:16:21 -0800 1997)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1998)   } // End of for all blocks fill in exception table entries
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 1999) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2000) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2001) // Static Variables
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2002) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2003) uint Scheduling::_total_nop_size = 0;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2004) uint Scheduling::_total_method_size = 0;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2005) uint Scheduling::_total_branches = 0;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2006) uint Scheduling::_total_unconditional_delays = 0;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2007) uint Scheduling::_total_instructions_per_bundle[Pipeline::_max_instrs_per_cycle+1];
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2008) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2009) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2010) // Initializer for class Scheduling
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2011) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2012) Scheduling::Scheduling(Arena *arena, Compile &compile)
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2013)         : _arena(arena),
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2014)           _cfg(compile.cfg()),
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2015)           _regalloc(compile.regalloc()),
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2016)           _scheduled(arena),
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2017)           _available(arena),
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2018)           _reg_node(arena),
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2019)           _pinch_free_list(arena),
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2020)           _next_node(NULL),
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2021)           _bundle_instr_count(0),
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2022)           _bundle_cycle_number(0),
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2023)           _bundle_use(0, 0, resource_count, &_bundle_use_elements[0])
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2024) #ifndef PRODUCT
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2025)         , _branches(0)
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2026)         , _unconditional_delays(0)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2027) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2028) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2029)   // Create a MachNopNode
2a0815a55e21 hotspot/src/share/vm/opto/output.cpp (Tobias Hartmann     2014-06-02 08:07:29 +0200 2030)   _nop = new MachNopNode();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2031) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2032)   // Now that the nops are in the array, save the count
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2033)   // (but allow entries for the nops)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2034)   _node_bundling_limit = compile.unique();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2035)   uint node_max = _regalloc->node_regs_max_index();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2036) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 2037)   compile.output()->set_node_bundling_limit(_node_bundling_limit);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2038) 
05d1de77274c hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2009-02-27 13:27:09 -0800 2039)   // This one is persistent within the Compile class
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2040)   _node_bundling_base = NEW_ARENA_ARRAY(compile.comp_arena(), Bundle, node_max);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2041) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2042)   // Allocate space for fixed-size arrays
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2043)   _node_latency    = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2044)   _uses            = NEW_ARENA_ARRAY(arena, short,          node_max);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2045)   _current_latency = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2046) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2047)   // Clear the arrays
e308392c733b src/hotspot/share/opto/output.cpp    (Dmitry Chuyko       2018-12-07 17:52:37 +0300 2048)   for (uint i = 0; i < node_max; i++) {
e308392c733b src/hotspot/share/opto/output.cpp    (Dmitry Chuyko       2018-12-07 17:52:37 +0300 2049)     ::new (&_node_bundling_base[i]) Bundle();
e308392c733b src/hotspot/share/opto/output.cpp    (Dmitry Chuyko       2018-12-07 17:52:37 +0300 2050)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2051)   memset(_node_latency,       0, node_max * sizeof(unsigned short));
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2052)   memset(_uses,               0, node_max * sizeof(short));
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2053)   memset(_current_latency,    0, node_max * sizeof(unsigned short));
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2054) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2055)   // Clear the bundling information
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 2056)   memcpy(_bundle_use_elements, Pipeline_Use::elaborated_elements, sizeof(Pipeline_Use::elaborated_elements));
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2057) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2058)   // Get the last node
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 2059)   Block* block = _cfg->get_block(_cfg->number_of_blocks() - 1);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2060) 
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 2061)   _next_node = block->get_node(block->number_of_nodes() - 1);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2062) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2063) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2064) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2065) // Scheduling destructor
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2066) Scheduling::~Scheduling() {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2067)   _total_branches             += _branches;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2068)   _total_unconditional_delays += _unconditional_delays;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2069) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2070) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2071) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2072) // Step ahead "i" cycles
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2073) void Scheduling::step(uint i) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2074) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2075)   Bundle *bundle = node_bundling(_next_node);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2076)   bundle->set_starts_bundle();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2077) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2078)   // Update the bundle record, but leave the flags information alone
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2079)   if (_bundle_instr_count > 0) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2080)     bundle->set_instr_count(_bundle_instr_count);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2081)     bundle->set_resources_used(_bundle_use.resourcesUsed());
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2082)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2083) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2084)   // Update the state information
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2085)   _bundle_instr_count = 0;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2086)   _bundle_cycle_number += i;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2087)   _bundle_use.step(i);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2088) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2089) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2090) void Scheduling::step_and_clear() {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2091)   Bundle *bundle = node_bundling(_next_node);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2092)   bundle->set_starts_bundle();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2093) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2094)   // Update the bundle record
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2095)   if (_bundle_instr_count > 0) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2096)     bundle->set_instr_count(_bundle_instr_count);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2097)     bundle->set_resources_used(_bundle_use.resourcesUsed());
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2098) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2099)     _bundle_cycle_number += 1;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2100)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2101) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2102)   // Clear the bundling information
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2103)   _bundle_instr_count = 0;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2104)   _bundle_use.reset();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2105) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2106)   memcpy(_bundle_use_elements,
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2107)          Pipeline_Use::elaborated_elements,
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2108)          sizeof(Pipeline_Use::elaborated_elements));
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2109) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2110) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2111) // Perform instruction scheduling and bundling over the sequence of
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2112) // instructions in backwards order.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 2113) void PhaseOutput::ScheduleAndBundle() {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2114) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2115)   // Don't optimize this if it isn't a method
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 2116)   if (!C->method())
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2117)     return;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2118) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2119)   // Don't optimize this if scheduling is disabled
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 2120)   if (!C->do_scheduling())
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2121)     return;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2122) 
802737cae70b src/hotspot/share/opto/output.cpp    (Nick Gasson         2020-07-07 14:14:22 +0800 2123)   // Scheduling code works only with pairs (8 bytes) maximum.
9d3379b9755e src/hotspot/share/opto/output.cpp    (Ningsheng Jian      2021-09-23 02:58:59 +0000 2124)   // And when the scalable vector register is used, we may spill/unspill
9d3379b9755e src/hotspot/share/opto/output.cpp    (Ningsheng Jian      2021-09-23 02:58:59 +0000 2125)   // the whole reg regardless of the max vector size.
9d3379b9755e src/hotspot/share/opto/output.cpp    (Ningsheng Jian      2021-09-23 02:58:59 +0000 2126)   if (C->max_vector_size() > 8 ||
9d3379b9755e src/hotspot/share/opto/output.cpp    (Ningsheng Jian      2021-09-23 02:58:59 +0000 2127)       (C->max_vector_size() > 0 && Matcher::supports_scalable_vector())) {
811c047ec1dc hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2012-09-17 19:39:07 -0700 2128)     return;
9d3379b9755e src/hotspot/share/opto/output.cpp    (Ningsheng Jian      2021-09-23 02:58:59 +0000 2129)   }
fbcc3da64fcb hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2012-08-23 09:13:16 -0700 2130) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 2131)   Compile::TracePhase tp("isched", &timers[_t_instrSched]);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2132) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2133)   // Create a data structure for all the scheduling information
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 2134)   Scheduling scheduling(Thread::current()->resource_area(), *C);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2135) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2136)   // Walk backwards over each basic block, computing the needed alignment
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2137)   // Walk over all the basic blocks
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2138)   scheduling.DoScheduling();
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2139) 
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2140) #ifndef PRODUCT
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 2141)   if (C->trace_opto_output()) {
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2142)     tty->print("\n---- After ScheduleAndBundle ----\n");
cbc5a5f669a6 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-17 18:26:39 +0100 2143)     print_scheduling();
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2144)   }
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2145) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2146) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2147) 
cbc5a5f669a6 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-17 18:26:39 +0100 2148) #ifndef PRODUCT
cbc5a5f669a6 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-17 18:26:39 +0100 2149) // Separated out so that it can be called directly from debugger
cbc5a5f669a6 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-17 18:26:39 +0100 2150) void PhaseOutput::print_scheduling() {
cbc5a5f669a6 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-17 18:26:39 +0100 2151)   for (uint i = 0; i < C->cfg()->number_of_blocks(); i++) {
cbc5a5f669a6 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-17 18:26:39 +0100 2152)     tty->print("\nBB#%03d:\n", i);
cbc5a5f669a6 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-17 18:26:39 +0100 2153)     Block* block = C->cfg()->get_block(i);
cbc5a5f669a6 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-17 18:26:39 +0100 2154)     for (uint j = 0; j < block->number_of_nodes(); j++) {
cbc5a5f669a6 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-17 18:26:39 +0100 2155)       Node* n = block->get_node(j);
cbc5a5f669a6 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-17 18:26:39 +0100 2156)       OptoReg::Name reg = C->regalloc()->get_reg_first(n);
cbc5a5f669a6 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-17 18:26:39 +0100 2157)       tty->print(" %-6s ", reg >= 0 && reg < REG_COUNT ? Matcher::regName[reg] : "");
cbc5a5f669a6 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-17 18:26:39 +0100 2158)       n->dump();
cbc5a5f669a6 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-17 18:26:39 +0100 2159)     }
cbc5a5f669a6 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-17 18:26:39 +0100 2160)   }
cbc5a5f669a6 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-17 18:26:39 +0100 2161) }
cbc5a5f669a6 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-17 18:26:39 +0100 2162) #endif
cbc5a5f669a6 src/hotspot/share/opto/output.cpp    (Nils Eliasson       2021-11-17 18:26:39 +0100 2163) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2164) // Compute the latency of all the instructions.  This is fairly simple,
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2165) // because we already have a legal ordering.  Walk over the instructions
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2166) // from first to last, and compute the latency of the instruction based
05d1de77274c hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2009-02-27 13:27:09 -0800 2167) // on the latency of the preceding instruction(s).
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2168) void Scheduling::ComputeLocalLatenciesForward(const Block *bb) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2169) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2170)   if (_cfg->C->trace_opto_output())
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2171)     tty->print("# -> ComputeLocalLatenciesForward\n");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2172) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2173) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2174)   // Walk over all the schedulable instructions
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2175)   for( uint j=_bb_start; j < _bb_end; j++ ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2176) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2177)     // This is a kludge, forcing all latency calculations to start at 1.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2178)     // Used to allow latency 0 to force an instruction to the beginning
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2179)     // of the bb
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2180)     uint latency = 1;
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 2181)     Node *use = bb->get_node(j);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2182)     uint nlen = use->len();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2183) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2184)     // Walk over all the inputs
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2185)     for ( uint k=0; k < nlen; k++ ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2186)       Node *def = use->in(k);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2187)       if (!def)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2188)         continue;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2189) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2190)       uint l = _node_latency[def->_idx] + use->latency(k);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2191)       if (latency < l)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2192)         latency = l;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2193)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2194) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2195)     _node_latency[use->_idx] = latency;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2196) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2197) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2198)     if (_cfg->C->trace_opto_output()) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2199)       tty->print("# latency %4d: ", latency);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2200)       use->dump();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2201)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2202) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2203)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2204) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2205) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2206)   if (_cfg->C->trace_opto_output())
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2207)     tty->print("# <- ComputeLocalLatenciesForward\n");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2208) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2209) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2210) } // end ComputeLocalLatenciesForward
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2211) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2212) // See if this node fits into the present instruction bundle
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2213) bool Scheduling::NodeFitsInBundle(Node *n) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2214)   uint n_idx = n->_idx;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2215) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2216)   // If this is the unconditional delay instruction, then it fits
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2217)   if (n == _unconditional_delay_slot) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2218) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2219)     if (_cfg->C->trace_opto_output())
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2220)       tty->print("#     NodeFitsInBundle [%4d]: TRUE; is in unconditional delay slot\n", n->_idx);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2221) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2222)     return (true);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2223)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2224) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2225)   // If the node cannot be scheduled this cycle, skip it
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2226)   if (_current_latency[n_idx] > _bundle_cycle_number) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2227) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2228)     if (_cfg->C->trace_opto_output())
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2229)       tty->print("#     NodeFitsInBundle [%4d]: FALSE; latency %4d > %d\n",
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2230)                  n->_idx, _current_latency[n_idx], _bundle_cycle_number);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2231) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2232)     return (false);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2233)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2234) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2235)   const Pipeline *node_pipeline = n->pipeline();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2236) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2237)   uint instruction_count = node_pipeline->instructionCount();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2238)   if (node_pipeline->mayHaveNoCode() && n->size(_regalloc) == 0)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2239)     instruction_count = 0;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2240)   else if (node_pipeline->hasBranchDelay() && !_unconditional_delay_slot)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2241)     instruction_count++;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2242) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2243)   if (_bundle_instr_count + instruction_count > Pipeline::_max_instrs_per_cycle) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2244) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2245)     if (_cfg->C->trace_opto_output())
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2246)       tty->print("#     NodeFitsInBundle [%4d]: FALSE; too many instructions: %d > %d\n",
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2247)                  n->_idx, _bundle_instr_count + instruction_count, Pipeline::_max_instrs_per_cycle);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2248) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2249)     return (false);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2250)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2251) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2252)   // Don't allow non-machine nodes to be handled this way
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2253)   if (!n->is_Mach() && instruction_count == 0)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2254)     return (false);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2255) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2256)   // See if there is any overlap
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2257)   uint delay = _bundle_use.full_latency(0, node_pipeline->resourceUse());
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2258) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2259)   if (delay > 0) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2260) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2261)     if (_cfg->C->trace_opto_output())
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2262)       tty->print("#     NodeFitsInBundle [%4d]: FALSE; functional units overlap\n", n_idx);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2263) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2264)     return false;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2265)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2266) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2267) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2268)   if (_cfg->C->trace_opto_output())
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2269)     tty->print("#     NodeFitsInBundle [%4d]:  TRUE\n", n_idx);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2270) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2271) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2272)   return true;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2273) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2274) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2275) Node * Scheduling::ChooseNodeToBundle() {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2276)   uint siz = _available.size();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2277) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2278)   if (siz == 0) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2279) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2280) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2281)     if (_cfg->C->trace_opto_output())
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2282)       tty->print("#   ChooseNodeToBundle: NULL\n");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2283) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2284)     return (NULL);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2285)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2286) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2287)   // Fast path, if only 1 instruction in the bundle
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2288)   if (siz == 1) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2289) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2290)     if (_cfg->C->trace_opto_output()) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2291)       tty->print("#   ChooseNodeToBundle (only 1): ");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2292)       _available[0]->dump();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2293)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2294) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2295)     return (_available[0]);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2296)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2297) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2298)   // Don't bother, if the bundle is already full
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2299)   if (_bundle_instr_count < Pipeline::_max_instrs_per_cycle) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2300)     for ( uint i = 0; i < siz; i++ ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2301)       Node *n = _available[i];
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2302) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2303)       // Skip projections, we'll handle them another way
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2304)       if (n->is_Proj())
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2305)         continue;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2306) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2307)       // This presupposed that instructions are inserted into the
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2308)       // available list in a legality order; i.e. instructions that
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2309)       // must be inserted first are at the head of the list
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2310)       if (NodeFitsInBundle(n)) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2311) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2312)         if (_cfg->C->trace_opto_output()) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2313)           tty->print("#   ChooseNodeToBundle: ");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2314)           n->dump();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2315)         }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2316) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2317)         return (n);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2318)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2319)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2320)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2321) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2322)   // Nothing fits in this bundle, choose the highest priority
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2323) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2324)   if (_cfg->C->trace_opto_output()) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2325)     tty->print("#   ChooseNodeToBundle: ");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2326)     _available[0]->dump();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2327)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2328) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2329) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2330)   return _available[0];
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2331) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2332) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2333) void Scheduling::AddNodeToAvailableList(Node *n) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2334)   assert( !n->is_Proj(), "projections never directly made available" );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2335) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2336)   if (_cfg->C->trace_opto_output()) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2337)     tty->print("#   AddNodeToAvailableList: ");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2338)     n->dump();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2339)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2340) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2341) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2342)   int latency = _current_latency[n->_idx];
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2343) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2344)   // Insert in latency order (insertion sort)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2345)   uint i;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2346)   for ( i=0; i < _available.size(); i++ )
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2347)     if (_current_latency[_available[i]->_idx] > latency)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2348)       break;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2349) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2350)   // Special Check for compares following branches
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2351)   if( n->is_Mach() && _scheduled.size() > 0 ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2352)     int op = n->as_Mach()->ideal_Opcode();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2353)     Node *last = _scheduled[0];
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2354)     if( last->is_MachIf() && last->in(1) == n &&
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2355)         ( op == Op_CmpI ||
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2356)           op == Op_CmpU ||
b6c0d9ee2318 hotspot/src/share/vm/opto/output.cpp (Tobias Hartmann     2017-03-23 15:14:18 +0100 2357)           op == Op_CmpUL ||
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2358)           op == Op_CmpP ||
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2359)           op == Op_CmpF ||
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2360)           op == Op_CmpD ||
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2361)           op == Op_CmpL ) ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2362) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2363)       // Recalculate position, moving to front of same latency
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2364)       for ( i=0 ; i < _available.size(); i++ )
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2365)         if (_current_latency[_available[i]->_idx] >= latency)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2366)           break;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2367)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2368)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2369) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2370)   // Insert the node in the available list
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2371)   _available.insert(i, n);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2372) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2373) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2374)   if (_cfg->C->trace_opto_output())
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2375)     dump_available();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2376) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2377) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2378) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2379) void Scheduling::DecrementUseCounts(Node *n, const Block *bb) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2380)   for ( uint i=0; i < n->len(); i++ ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2381)     Node *def = n->in(i);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2382)     if (!def) continue;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2383)     if( def->is_Proj() )        // If this is a machine projection, then
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2384)       def = def->in(0);         // propagate usage thru to the base instruction
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2385) 
bfe8385fa926 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-07 17:56:19 +0200 2386)     if(_cfg->get_block_for_node(def) != bb) { // Ignore if not block-local
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2387)       continue;
bfe8385fa926 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-07 17:56:19 +0200 2388)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2389) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2390)     // Compute the latency
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2391)     uint l = _bundle_cycle_number + n->latency(i);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2392)     if (_current_latency[def->_idx] < l)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2393)       _current_latency[def->_idx] = l;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2394) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2395)     // If this does not have uses then schedule it
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2396)     if ((--_uses[def->_idx]) == 0)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2397)       AddNodeToAvailableList(def);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2398)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2399) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2400) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2401) void Scheduling::AddNodeToBundle(Node *n, const Block *bb) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2402) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2403)   if (_cfg->C->trace_opto_output()) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2404)     tty->print("#   AddNodeToBundle: ");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2405)     n->dump();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2406)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2407) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2408) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2409)   // Remove this from the available list
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2410)   uint i;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2411)   for (i = 0; i < _available.size(); i++)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2412)     if (_available[i] == n)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2413)       break;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2414)   assert(i < _available.size(), "entry in _available list not found");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2415)   _available.remove(i);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2416) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2417)   // See if this fits in the current bundle
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2418)   const Pipeline *node_pipeline = n->pipeline();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2419)   const Pipeline_Use& node_usage = node_pipeline->resourceUse();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2420) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2421)   // Check for instructions to be placed in the delay slot. We
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2422)   // do this before we actually schedule the current instruction,
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2423)   // because the delay slot follows the current instruction.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2424)   if (Pipeline::_branch_has_delay_slot &&
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2425)       node_pipeline->hasBranchDelay() &&
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2426)       !_unconditional_delay_slot) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2427) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2428)     uint siz = _available.size();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2429) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2430)     // Conditional branches can support an instruction that
05d1de77274c hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2009-02-27 13:27:09 -0800 2431)     // is unconditionally executed and not dependent by the
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2432)     // branch, OR a conditionally executed instruction if
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2433)     // the branch is taken.  In practice, this means that
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2434)     // the first instruction at the branch target is
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2435)     // copied to the delay slot, and the branch goes to
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2436)     // the instruction after that at the branch target
080f790edc7f hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-16 11:53:57 -0700 2437)     if ( n->is_MachBranch() ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2438) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2439)       assert( !n->is_MachNullCheck(), "should not look for delay slot for Null Check" );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2440)       assert( !n->is_Catch(),         "should not look for delay slot for Catch" );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2441) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2442) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2443)       _branches++;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2444) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2445) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2446)       // At least 1 instruction is on the available list
05d1de77274c hotspot/src/share/vm/opto/output.cpp (Christian Thalinger 2009-02-27 13:27:09 -0800 2447)       // that is not dependent on the branch
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2448)       for (uint i = 0; i < siz; i++) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2449)         Node *d = _available[i];
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2450)         const Pipeline *avail_pipeline = d->pipeline();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2451) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2452)         // Don't allow safepoints in the branch shadow, that will
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2453)         // cause a number of difficulties
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2454)         if ( avail_pipeline->instructionCount() == 1 &&
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2455)              !avail_pipeline->hasMultipleBundles() &&
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2456)              !avail_pipeline->hasBranchDelay() &&
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2457)              Pipeline::instr_has_unit_size() &&
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2458)              d->size(_regalloc) == Pipeline::instr_unit_size() &&
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2459)              NodeFitsInBundle(d) &&
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2460)              !node_bundling(d)->used_in_delay()) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2461) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2462)           if (d->is_Mach() && !d->is_MachSafePoint()) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2463)             // A node that fits in the delay slot was found, so we need to
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2464)             // set the appropriate bits in the bundle pipeline information so
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2465)             // that it correctly indicates resource usage.  Later, when we
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2466)             // attempt to add this instruction to the bundle, we will skip
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2467)             // setting the resource usage.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2468)             _unconditional_delay_slot = d;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2469)             node_bundling(n)->set_use_unconditional_delay();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2470)             node_bundling(d)->set_used_in_unconditional_delay();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2471)             _bundle_use.add_usage(avail_pipeline->resourceUse());
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2472)             _current_latency[d->_idx] = _bundle_cycle_number;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2473)             _next_node = d;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2474)             ++_bundle_instr_count;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2475) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2476)             _unconditional_delays++;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2477) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2478)             break;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2479)           }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2480)         }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2481)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2482)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2483) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2484)     // No delay slot, add a nop to the usage
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2485)     if (!_unconditional_delay_slot) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2486)       // See if adding an instruction in the delay slot will overflow
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2487)       // the bundle.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2488)       if (!NodeFitsInBundle(_nop)) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2489) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2490)         if (_cfg->C->trace_opto_output())
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2491)           tty->print("#  *** STEP(1 instruction for delay slot) ***\n");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2492) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2493)         step(1);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2494)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2495) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2496)       _bundle_use.add_usage(_nop->pipeline()->resourceUse());
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2497)       _next_node = _nop;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2498)       ++_bundle_instr_count;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2499)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2500) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2501)     // See if the instruction in the delay slot requires a
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2502)     // step of the bundles
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2503)     if (!NodeFitsInBundle(n)) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2504) #ifndef PRODUCT
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2505)       if (_cfg->C->trace_opto_output())
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2506)         tty->print("#  *** STEP(branch won't fit) ***\n");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2507) #endif
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2508)       // Update the state information
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2509)       _bundle_instr_count = 0;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2510)       _bundle_cycle_number += 1;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2511)       _bundle_use.step(1);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2512)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2513)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2514) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2515)   // Get the number of instructions
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2516)   uint instruction_count = node_pipeline->instructionCount();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2517)   if (node_pipeline->mayHaveNoCode() && n->size(_regalloc) == 0)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2518)     instruction_count = 0;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2519) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2520)   // Compute the latency information
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2521)   uint delay = 0;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2522) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2523)   if (instruction_count > 0 || !node_pipeline->mayHaveNoCode()) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2524)     int relative_latency = _current_latency[n->_idx] - _bundle_cycle_number;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2525)     if (relative_latency < 0)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2526)       relative_latency = 0;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2527) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2528)     delay = _bundle_use.full_latency(relative_latency, node_usage);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2529) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2530)     // Does not fit in this bundle, start a new one
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2531)     if (delay > 0) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2532)       step(delay);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2533) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2534) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2535)       if (_cfg->C->trace_opto_output())
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2536)         tty->print("#  *** STEP(%d) ***\n", delay);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2537) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2538)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2539)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2540) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2541)   // If this was placed in the delay slot, ignore it
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2542)   if (n != _unconditional_delay_slot) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2543) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2544)     if (delay == 0) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2545)       if (node_pipeline->hasMultipleBundles()) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2546) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2547)         if (_cfg->C->trace_opto_output())
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2548)           tty->print("#  *** STEP(multiple instructions) ***\n");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2549) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2550)         step(1);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2551)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2552) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2553)       else if (instruction_count + _bundle_instr_count > Pipeline::_max_instrs_per_cycle) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2554) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2555)         if (_cfg->C->trace_opto_output())
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2556)           tty->print("#  *** STEP(%d >= %d instructions) ***\n",
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2557)                      instruction_count + _bundle_instr_count,
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2558)                      Pipeline::_max_instrs_per_cycle);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2559) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2560)         step(1);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2561)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2562)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2563) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2564)     if (node_pipeline->hasBranchDelay() && !_unconditional_delay_slot)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2565)       _bundle_instr_count++;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2566) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2567)     // Set the node's latency
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2568)     _current_latency[n->_idx] = _bundle_cycle_number;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2569) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2570)     // Now merge the functional unit information
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2571)     if (instruction_count > 0 || !node_pipeline->mayHaveNoCode())
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2572)       _bundle_use.add_usage(node_usage);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2573) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2574)     // Increment the number of instructions in this bundle
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2575)     _bundle_instr_count += instruction_count;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2576) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2577)     // Remember this node for later
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2578)     if (n->is_Mach())
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2579)       _next_node = n;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2580)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2581) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2582)   // It's possible to have a BoxLock in the graph and in the _bbs mapping but
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2583)   // not in the bb->_nodes array.  This happens for debug-info-only BoxLocks.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2584)   // 'Schedule' them (basically ignore in the schedule) but do not insert them
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2585)   // into the block.  All other scheduled nodes get put in the schedule here.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2586)   int op = n->Opcode();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2587)   if( (op == Op_Node && n->req() == 0) || // anti-dependence node OR
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2588)       (op != Op_Node &&         // Not an unused antidepedence node and
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2589)        // not an unallocated boxlock
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2590)        (OptoReg::is_valid(_regalloc->get_reg_first(n)) || op != Op_BoxLock)) ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2591) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2592)     // Push any trailing projections
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 2593)     if( bb->get_node(bb->number_of_nodes()-1) != n ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2594)       for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2595)         Node *foi = n->fast_out(i);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2596)         if( foi->is_Proj() )
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2597)           _scheduled.push(foi);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2598)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2599)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2600) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2601)     // Put the instruction in the schedule list
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2602)     _scheduled.push(n);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2603)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2604) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2605) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2606)   if (_cfg->C->trace_opto_output())
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2607)     dump_available();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2608) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2609) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2610)   // Walk all the definitions, decrementing use counts, and
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2611)   // if a definition has a 0 use count, place it in the available list.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2612)   DecrementUseCounts(n,bb);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2613) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2614) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2615) // This method sets the use count within a basic block.  We will ignore all
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2616) // uses outside the current basic block.  As we are doing a backwards walk,
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2617) // any node we reach that has a use count of 0 may be scheduled.  This also
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2618) // avoids the problem of cyclic references from phi nodes, as long as phi
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2619) // nodes are at the front of the basic block.  This method also initializes
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2620) // the available list to the set of instructions that have no uses within this
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2621) // basic block.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2622) void Scheduling::ComputeUseCount(const Block *bb) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2623) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2624)   if (_cfg->C->trace_opto_output())
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2625)     tty->print("# -> ComputeUseCount\n");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2626) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2627) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2628)   // Clear the list of available and scheduled instructions, just in case
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2629)   _available.clear();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2630)   _scheduled.clear();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2631) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2632)   // No delay slot specified
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2633)   _unconditional_delay_slot = NULL;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2634) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2635) #ifdef ASSERT
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 2636)   for( uint i=0; i < bb->number_of_nodes(); i++ )
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 2637)     assert( _uses[bb->get_node(i)->_idx] == 0, "_use array not clean" );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2638) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2639) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2640)   // Force the _uses count to never go to zero for unscheduable pieces
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2641)   // of the block
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2642)   for( uint k = 0; k < _bb_start; k++ )
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 2643)     _uses[bb->get_node(k)->_idx] = 1;
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 2644)   for( uint l = _bb_end; l < bb->number_of_nodes(); l++ )
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 2645)     _uses[bb->get_node(l)->_idx] = 1;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2646) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2647)   // Iterate backwards over the instructions in the block.  Don't count the
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2648)   // branch projections at end or the block header instructions.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2649)   for( uint j = _bb_end-1; j >= _bb_start; j-- ) {
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 2650)     Node *n = bb->get_node(j);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2651)     if( n->is_Proj() ) continue; // Projections handled another way
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2652) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2653)     // Account for all uses
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2654)     for ( uint k = 0; k < n->len(); k++ ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2655)       Node *inp = n->in(k);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2656)       if (!inp) continue;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2657)       assert(inp != n, "no cycles allowed" );
bfe8385fa926 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-07 17:56:19 +0200 2658)       if (_cfg->get_block_for_node(inp) == bb) { // Block-local use?
bfe8385fa926 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-07 17:56:19 +0200 2659)         if (inp->is_Proj()) { // Skip through Proj's
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2660)           inp = inp->in(0);
bfe8385fa926 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-07 17:56:19 +0200 2661)         }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2662)         ++_uses[inp->_idx];     // Count 1 block-local use
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2663)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2664)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2665) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2666)     // If this instruction has a 0 use count, then it is available
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2667)     if (!_uses[n->_idx]) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2668)       _current_latency[n->_idx] = _bundle_cycle_number;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2669)       AddNodeToAvailableList(n);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2670)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2671) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2672) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2673)     if (_cfg->C->trace_opto_output()) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2674)       tty->print("#   uses: %3d: ", _uses[n->_idx]);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2675)       n->dump();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2676)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2677) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2678)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2679) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2680) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2681)   if (_cfg->C->trace_opto_output())
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2682)     tty->print("# <- ComputeUseCount\n");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2683) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2684) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2685) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2686) // This routine performs scheduling on each basic block in reverse order,
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2687) // using instruction latencies and taking into account function unit
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2688) // availability.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2689) void Scheduling::DoScheduling() {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2690) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2691)   if (_cfg->C->trace_opto_output())
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2692)     tty->print("# -> DoScheduling\n");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2693) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2694) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2695)   Block *succ_bb = NULL;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2696)   Block *bb;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 2697)   Compile* C = Compile::current();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2698) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2699)   // Walk over all the basic blocks in reverse order
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 2700)   for (int i = _cfg->number_of_blocks() - 1; i >= 0; succ_bb = bb, i--) {
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 2701)     bb = _cfg->get_block(i);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2702) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2703) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2704)     if (_cfg->C->trace_opto_output()) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2705)       tty->print("#  Schedule BB#%03d (initial)\n", i);
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 2706)       for (uint j = 0; j < bb->number_of_nodes(); j++) {
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 2707)         bb->get_node(j)->dump();
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 2708)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2709)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2710) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2711) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2712)     // On the head node, skip processing
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 2713)     if (bb == _cfg->get_root_block()) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2714)       continue;
a235ecb3449a hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-16 10:23:55 +0200 2715)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2716) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2717)     // Skip empty, connector blocks
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2718)     if (bb->is_connector())
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2719)       continue;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2720) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2721)     // If the following block is not the sole successor of
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2722)     // this one, then reset the pipeline information
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2723)     if (bb->_num_succs != 1 || bb->non_connector_successor(0) != succ_bb) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2724) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2725)       if (_cfg->C->trace_opto_output()) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2726)         tty->print("*** bundle start of next BB, node %d, for %d instructions\n",
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2727)                    _next_node->_idx, _bundle_instr_count);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2728)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2729) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2730)       step_and_clear();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2731)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2732) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2733)     // Leave untouched the starting instruction, any Phis, a CreateEx node
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 2734)     // or Top.  bb->get_node(_bb_start) is the first schedulable instruction.
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 2735)     _bb_end = bb->number_of_nodes()-1;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2736)     for( _bb_start=1; _bb_start <= _bb_end; _bb_start++ ) {
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 2737)       Node *n = bb->get_node(_bb_start);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2738)       // Things not matched, like Phinodes and ProjNodes don't get scheduled.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2739)       // Also, MachIdealNodes do not get scheduled
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2740)       if( !n->is_Mach() ) continue;     // Skip non-machine nodes
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2741)       MachNode *mach = n->as_Mach();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2742)       int iop = mach->ideal_Opcode();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2743)       if( iop == Op_CreateEx ) continue; // CreateEx is pinned
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2744)       if( iop == Op_Con ) continue;      // Do not schedule Top
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2745)       if( iop == Op_Node &&     // Do not schedule PhiNodes, ProjNodes
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2746)           mach->pipeline() == MachNode::pipeline_class() &&
903cbcb4df53 hotspot/src/share/vm/opto/output.cpp (Igor Veresov        2015-01-22 11:25:23 -0800 2747)           !n->is_SpillCopy() && !n->is_MachMerge() )  // Breakpoints, Prolog, etc
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2748)         continue;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2749)       break;                    // Funny loop structure to be sure...
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2750)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2751)     // Compute last "interesting" instruction in block - last instruction we
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2752)     // might schedule.  _bb_end points just after last schedulable inst.  We
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2753)     // normally schedule conditional branches (despite them being forced last
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2754)     // in the block), because they have delay slots we can fill.  Calls all
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2755)     // have their delay slots filled in the template expansions, so we don't
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2756)     // bother scheduling them.
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 2757)     Node *last = bb->get_node(_bb_end);
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 2758)     // Ignore trailing NOPs.
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 2759)     while (_bb_end > 0 && last->is_Mach() &&
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 2760)            last->as_Mach()->ideal_Opcode() == Op_Con) {
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 2761)       last = bb->get_node(--_bb_end);
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 2762)     }
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 2763)     assert(!last->is_Mach() || last->as_Mach()->ideal_Opcode() != Op_Con, "");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2764)     if( last->is_Catch() ||
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2765)         (last->is_Mach() && last->as_Mach()->ideal_Opcode() == Op_Halt) ) {
31d261dda24c src/hotspot/share/opto/output.cpp    (Tobias Hartmann     2019-06-12 14:06:16 +0200 2766)       // There might be a prior call.  Skip it.
31d261dda24c src/hotspot/share/opto/output.cpp    (Tobias Hartmann     2019-06-12 14:06:16 +0200 2767)       while (_bb_start < _bb_end && bb->get_node(--_bb_end)->is_MachProj());
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2768)     } else if( last->is_MachNullCheck() ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2769)       // Backup so the last null-checked memory instruction is
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2770)       // outside the schedulable range. Skip over the nullcheck,
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2771)       // projection, and the memory nodes.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2772)       Node *mem = last->in(1);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2773)       do {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2774)         _bb_end--;
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 2775)       } while (mem != bb->get_node(_bb_end));
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2776)     } else {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2777)       // Set _bb_end to point after last schedulable inst.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2778)       _bb_end++;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2779)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2780) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2781)     assert( _bb_start <= _bb_end, "inverted block ends" );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2782) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2783)     // Compute the register antidependencies for the basic block
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2784)     ComputeRegisterAntidependencies(bb);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 2785)     if (C->failing())  return;  // too many D-U pinch points
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2786) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2787)     // Compute intra-bb latencies for the nodes
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2788)     ComputeLocalLatenciesForward(bb);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2789) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2790)     // Compute the usage within the block, and set the list of all nodes
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2791)     // in the block that have no uses within the block.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2792)     ComputeUseCount(bb);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2793) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2794)     // Schedule the remaining instructions in the block
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2795)     while ( _available.size() > 0 ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2796)       Node *n = ChooseNodeToBundle();
887dd2634cdb hotspot/src/share/vm/opto/output.cpp (Morris Meyer        2013-03-19 07:20:15 -0700 2797)       guarantee(n != NULL, "no nodes available");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2798)       AddNodeToBundle(n,bb);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2799)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2800) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2801)     assert( _scheduled.size() == _bb_end - _bb_start, "wrong number of instructions" );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2802) #ifdef ASSERT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2803)     for( uint l = _bb_start; l < _bb_end; l++ ) {
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 2804)       Node *n = bb->get_node(l);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2805)       uint m;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2806)       for( m = 0; m < _bb_end-_bb_start; m++ )
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2807)         if( _scheduled[m] == n )
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2808)           break;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2809)       assert( m < _bb_end-_bb_start, "instruction missing in schedule" );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2810)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2811) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2812) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2813)     // Now copy the instructions (in reverse order) back to the block
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2814)     for ( uint k = _bb_start; k < _bb_end; k++ )
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 2815)       bb->map_node(_scheduled[_bb_end-k-1], k);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2816) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2817) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2818)     if (_cfg->C->trace_opto_output()) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2819)       tty->print("#  Schedule BB#%03d (final)\n", i);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2820)       uint current = 0;
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 2821)       for (uint j = 0; j < bb->number_of_nodes(); j++) {
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 2822)         Node *n = bb->get_node(j);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2823)         if( valid_bundle_info(n) ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2824)           Bundle *bundle = node_bundling(n);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2825)           if (bundle->instr_count() > 0 || bundle->flags() > 0) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2826)             tty->print("*** Bundle: ");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2827)             bundle->dump();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2828)           }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2829)           n->dump();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2830)         }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2831)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2832)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2833) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2834) #ifdef ASSERT
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 2835)     verify_good_schedule(bb,"after block local scheduling");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2836) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2837)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2838) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2839) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2840)   if (_cfg->C->trace_opto_output())
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2841)     tty->print("# <- DoScheduling\n");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2842) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2843) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2844)   // Record final node-bundling array location
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 2845)   _regalloc->C->output()->set_node_bundling_base(_node_bundling_base);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2846) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2847) } // end DoScheduling
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2848) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2849) // Verify that no live-range used in the block is killed in the block by a
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2850) // wrong DEF.  This doesn't verify live-ranges that span blocks.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2851) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2852) // Check for edge existence.  Used to avoid adding redundant precedence edges.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2853) static bool edge_from_to( Node *from, Node *to ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2854)   for( uint i=0; i<from->len(); i++ )
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2855)     if( from->in(i) == to )
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2856)       return true;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2857)   return false;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2858) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2859) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2860) #ifdef ASSERT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2861) void Scheduling::verify_do_def( Node *n, OptoReg::Name def, const char *msg ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2862)   // Check for bad kills
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2863)   if( OptoReg::is_valid(def) ) { // Ignore stores & control flow
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2864)     Node *prior_use = _reg_node[def];
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2865)     if( prior_use && !edge_from_to(prior_use,n) ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2866)       tty->print("%s = ",OptoReg::as_VMReg(def)->name());
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2867)       n->dump();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2868)       tty->print_cr("...");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2869)       prior_use->dump();
1e71f6773659 hotspot/src/share/vm/opto/output.cpp (David Lindholm      2015-09-29 11:02:08 +0200 2870)       assert(edge_from_to(prior_use,n), "%s", msg);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2871)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2872)     _reg_node.map(def,NULL); // Kill live USEs
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2873)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2874) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2875) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2876) void Scheduling::verify_good_schedule( Block *b, const char *msg ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2877) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2878)   // Zap to something reasonable for the verify code
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2879)   _reg_node.clear();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2880) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2881)   // Walk over the block backwards.  Check to make sure each DEF doesn't
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2882)   // kill a live value (other than the one it's supposed to).  Add each
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2883)   // USE to the live set.
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 2884)   for( uint i = b->number_of_nodes()-1; i >= _bb_start; i-- ) {
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 2885)     Node *n = b->get_node(i);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2886)     int n_op = n->Opcode();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2887)     if( n_op == Op_MachProj && n->ideal_reg() == MachProjNode::fat_proj ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2888)       // Fat-proj kills a slew of registers
fa3cfcd0cd8f src/hotspot/share/opto/output.cpp    (Claes Redestad      2020-11-24 14:35:51 +0000 2889)       RegMaskIterator rmi(n->out_RegMask());
fa3cfcd0cd8f src/hotspot/share/opto/output.cpp    (Claes Redestad      2020-11-24 14:35:51 +0000 2890)       while (rmi.has_next()) {
fa3cfcd0cd8f src/hotspot/share/opto/output.cpp    (Claes Redestad      2020-11-24 14:35:51 +0000 2891)         OptoReg::Name kill = rmi.next();
fa3cfcd0cd8f src/hotspot/share/opto/output.cpp    (Claes Redestad      2020-11-24 14:35:51 +0000 2892)         verify_do_def(n, kill, msg);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2893)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2894)     } else if( n_op != Op_Node ) { // Avoid brand new antidependence nodes
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2895)       // Get DEF'd registers the normal way
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2896)       verify_do_def( n, _regalloc->get_reg_first(n), msg );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2897)       verify_do_def( n, _regalloc->get_reg_second(n), msg );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2898)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2899) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2900)     // Now make all USEs live
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2901)     for( uint i=1; i<n->req(); i++ ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2902)       Node *def = n->in(i);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2903)       assert(def != 0, "input edge required");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2904)       OptoReg::Name reg_lo = _regalloc->get_reg_first(def);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2905)       OptoReg::Name reg_hi = _regalloc->get_reg_second(def);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2906)       if( OptoReg::is_valid(reg_lo) ) {
1e71f6773659 hotspot/src/share/vm/opto/output.cpp (David Lindholm      2015-09-29 11:02:08 +0200 2907)         assert(!_reg_node[reg_lo] || edge_from_to(_reg_node[reg_lo],def), "%s", msg);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2908)         _reg_node.map(reg_lo,n);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2909)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2910)       if( OptoReg::is_valid(reg_hi) ) {
1e71f6773659 hotspot/src/share/vm/opto/output.cpp (David Lindholm      2015-09-29 11:02:08 +0200 2911)         assert(!_reg_node[reg_hi] || edge_from_to(_reg_node[reg_hi],def), "%s", msg);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2912)         _reg_node.map(reg_hi,n);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2913)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2914)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2915) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2916)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2917) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2918)   // Zap to something reasonable for the Antidependence code
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2919)   _reg_node.clear();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2920) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2921) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2922) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2923) // Conditionally add precedence edges.  Avoid putting edges on Projs.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2924) static void add_prec_edge_from_to( Node *from, Node *to ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2925)   if( from->is_Proj() ) {       // Put precedence edge on Proj's input
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2926)     assert( from->req() == 1 && (from->len() == 1 || from->in(1)==0), "no precedence edges on projections" );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2927)     from = from->in(0);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2928)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2929)   if( from != to &&             // No cycles (for things like LD L0,[L0+4] )
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2930)       !edge_from_to( from, to ) ) // Avoid duplicate edge
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2931)     from->add_prec(to);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2932) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2933) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2934) void Scheduling::anti_do_def( Block *b, Node *def, OptoReg::Name def_reg, int is_def ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2935)   if( !OptoReg::is_valid(def_reg) ) // Ignore stores & control flow
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2936)     return;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2937) 
3934fe54b4c3 src/hotspot/share/opto/output.cpp    (Nick Gasson         2021-11-08 06:40:49 +0000 2938)   if (OptoReg::is_reg(def_reg)) {
3934fe54b4c3 src/hotspot/share/opto/output.cpp    (Nick Gasson         2021-11-08 06:40:49 +0000 2939)     VMReg vmreg = OptoReg::as_VMReg(def_reg);
3934fe54b4c3 src/hotspot/share/opto/output.cpp    (Nick Gasson         2021-11-08 06:40:49 +0000 2940)     if (vmreg->is_reg() && !vmreg->is_concrete() && !vmreg->prev()->is_concrete()) {
3934fe54b4c3 src/hotspot/share/opto/output.cpp    (Nick Gasson         2021-11-08 06:40:49 +0000 2941)       // This is one of the high slots of a vector register.
3934fe54b4c3 src/hotspot/share/opto/output.cpp    (Nick Gasson         2021-11-08 06:40:49 +0000 2942)       // ScheduleAndBundle already checked there are no live wide
3934fe54b4c3 src/hotspot/share/opto/output.cpp    (Nick Gasson         2021-11-08 06:40:49 +0000 2943)       // vectors in this method so it can be safely ignored.
3934fe54b4c3 src/hotspot/share/opto/output.cpp    (Nick Gasson         2021-11-08 06:40:49 +0000 2944)       return;
3934fe54b4c3 src/hotspot/share/opto/output.cpp    (Nick Gasson         2021-11-08 06:40:49 +0000 2945)     }
3934fe54b4c3 src/hotspot/share/opto/output.cpp    (Nick Gasson         2021-11-08 06:40:49 +0000 2946)   }
3934fe54b4c3 src/hotspot/share/opto/output.cpp    (Nick Gasson         2021-11-08 06:40:49 +0000 2947) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2948)   Node *pinch = _reg_node[def_reg]; // Get pinch point
bfe8385fa926 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-07 17:56:19 +0200 2949)   if ((pinch == NULL) || _cfg->get_block_for_node(pinch) != b || // No pinch-point yet?
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2950)       is_def ) {    // Check for a true def (not a kill)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2951)     _reg_node.map(def_reg,def); // Record def/kill as the optimistic pinch-point
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2952)     return;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2953)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2954) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2955)   Node *kill = def;             // Rename 'def' to more descriptive 'kill'
b085ebe7b775 src/hotspot/share/opto/output.cpp    (Lois Foltan         2018-02-20 07:46:40 -0500 2956)   debug_only( def = (Node*)((intptr_t)0xdeadbeef); )
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2957) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2958)   // After some number of kills there _may_ be a later def
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2959)   Node *later_def = NULL;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2960) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 2961)   Compile* C = Compile::current();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 2962) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2963)   // Finding a kill requires a real pinch-point.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2964)   // Check for not already having a pinch-point.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2965)   // Pinch points are Op_Node's.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2966)   if( pinch->Opcode() != Op_Node ) { // Or later-def/kill as pinch-point?
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2967)     later_def = pinch;            // Must be def/kill as optimistic pinch-point
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2968)     if ( _pinch_free_list.size() > 0) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2969)       pinch = _pinch_free_list.pop();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2970)     } else {
2a0815a55e21 hotspot/src/share/vm/opto/output.cpp (Tobias Hartmann     2014-06-02 08:07:29 +0200 2971)       pinch = new Node(1); // Pinch point to-be
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2972)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2973)     if (pinch->_idx >= _regalloc->node_regs_max_index()) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2974)       _cfg->C->record_method_not_compilable("too many D-U pinch points");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2975)       return;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2976)     }
bfe8385fa926 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-07 17:56:19 +0200 2977)     _cfg->map_node_to_block(pinch, b);      // Pretend it's valid in this block (lazy init)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2978)     _reg_node.map(def_reg,pinch); // Record pinch-point
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 2979)     //regalloc()->set_bad(pinch->_idx); // Already initialized this way.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2980)     if( later_def->outcnt() == 0 || later_def->ideal_reg() == MachProjNode::fat_proj ) { // Distinguish def from kill
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 2981)       pinch->init_req(0, C->top());     // set not NULL for the next call
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2982)       add_prec_edge_from_to(later_def,pinch); // Add edge from kill to pinch
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2983)       later_def = NULL;           // and no later def
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2984)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2985)     pinch->set_req(0,later_def);  // Hook later def so we can find it
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2986)   } else {                        // Else have valid pinch point
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2987)     if( pinch->in(0) )            // If there is a later-def
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2988)       later_def = pinch->in(0);   // Get it
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2989)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2990) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2991)   // Add output-dependence edge from later def to kill
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2992)   if( later_def )               // If there is some original def
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2993)     add_prec_edge_from_to(later_def,kill); // Add edge from def to kill
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2994) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2995)   // See if current kill is also a use, and so is forced to be the pinch-point.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2996)   if( pinch->Opcode() == Op_Node ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2997)     Node *uses = kill->is_Proj() ? kill->in(0) : kill;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2998)     for( uint i=1; i<uses->req(); i++ ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 2999)       if( _regalloc->get_reg_first(uses->in(i)) == def_reg ||
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3000)           _regalloc->get_reg_second(uses->in(i)) == def_reg ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3001)         // Yes, found a use/kill pinch-point
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3002)         pinch->set_req(0,NULL);  //
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3003)         pinch->replace_by(kill); // Move anti-dep edges up
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3004)         pinch = kill;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3005)         _reg_node.map(def_reg,pinch);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3006)         return;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3007)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3008)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3009)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3010) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3011)   // Add edge from kill to pinch-point
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3012)   add_prec_edge_from_to(kill,pinch);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3013) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3014) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3015) void Scheduling::anti_do_use( Block *b, Node *use, OptoReg::Name use_reg ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3016)   if( !OptoReg::is_valid(use_reg) ) // Ignore stores & control flow
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3017)     return;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3018)   Node *pinch = _reg_node[use_reg]; // Get pinch point
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3019)   // Check for no later def_reg/kill in block
bfe8385fa926 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-07 17:56:19 +0200 3020)   if ((pinch != NULL) && _cfg->get_block_for_node(pinch) == b &&
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3021)       // Use has to be block-local as well
bfe8385fa926 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-07 17:56:19 +0200 3022)       _cfg->get_block_for_node(use) == b) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3023)     if( pinch->Opcode() == Op_Node && // Real pinch-point (not optimistic?)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3024)         pinch->req() == 1 ) {   // pinch not yet in block?
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3025)       pinch->del_req(0);        // yank pointer to later-def, also set flag
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3026)       // Insert the pinch-point in the block just after the last use
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 3027)       b->insert_node(pinch, b->find_node(use) + 1);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3028)       _bb_end++;                // Increase size scheduled region in block
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3029)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3030) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3031)     add_prec_edge_from_to(pinch,use);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3032)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3033) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3034) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3035) // We insert antidependences between the reads and following write of
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3036) // allocated registers to prevent illegal code motion. Hopefully, the
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3037) // number of added references should be fairly small, especially as we
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3038) // are only adding references within the current basic block.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3039) void Scheduling::ComputeRegisterAntidependencies(Block *b) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3040) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3041) #ifdef ASSERT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3042)   verify_good_schedule(b,"before block local scheduling");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3043) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3044) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3045)   // A valid schedule, for each register independently, is an endless cycle
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3046)   // of: a def, then some uses (connected to the def by true dependencies),
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3047)   // then some kills (defs with no uses), finally the cycle repeats with a new
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3048)   // def.  The uses are allowed to float relative to each other, as are the
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3049)   // kills.  No use is allowed to slide past a kill (or def).  This requires
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3050)   // antidependencies between all uses of a single def and all kills that
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3051)   // follow, up to the next def.  More edges are redundant, because later defs
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3052)   // & kills are already serialized with true or antidependencies.  To keep
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3053)   // the edge count down, we add a 'pinch point' node if there's more than
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3054)   // one use or more than one kill/def.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3055) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3056)   // We add dependencies in one bottom-up pass.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3057) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3058)   // For each instruction we handle it's DEFs/KILLs, then it's USEs.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3059) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3060)   // For each DEF/KILL, we check to see if there's a prior DEF/KILL for this
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3061)   // register.  If not, we record the DEF/KILL in _reg_node, the
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3062)   // register-to-def mapping.  If there is a prior DEF/KILL, we insert a
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3063)   // "pinch point", a new Node that's in the graph but not in the block.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3064)   // We put edges from the prior and current DEF/KILLs to the pinch point.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3065)   // We put the pinch point in _reg_node.  If there's already a pinch point
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3066)   // we merely add an edge from the current DEF/KILL to the pinch point.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3067) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3068)   // After doing the DEF/KILLs, we handle USEs.  For each used register, we
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3069)   // put an edge from the pinch point to the USE.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3070) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3071)   // To be expedient, the _reg_node array is pre-allocated for the whole
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3072)   // compilation.  _reg_node is lazily initialized; it either contains a NULL,
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3073)   // or a valid def/kill/pinch-point, or a leftover node from some prior
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3074)   // block.  Leftover node from some prior block is treated like a NULL (no
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3075)   // prior def, so no anti-dependence needed).  Valid def is distinguished by
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3076)   // it being in the current block.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3077)   bool fat_proj_seen = false;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3078)   uint last_safept = _bb_end-1;
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 3079)   Node* end_node         = (_bb_end-1 >= _bb_start) ? b->get_node(last_safept) : NULL;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3080)   Node* last_safept_node = end_node;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3081)   for( uint i = _bb_end-1; i >= _bb_start; i-- ) {
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 3082)     Node *n = b->get_node(i);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3083)     int is_def = n->outcnt();   // def if some uses prior to adding precedence edges
18329266ea16 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-07-27 17:28:36 -0700 3084)     if( n->is_MachProj() && n->ideal_reg() == MachProjNode::fat_proj ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3085)       // Fat-proj kills a slew of registers
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3086)       // This can add edges to 'n' and obscure whether or not it was a def,
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3087)       // hence the is_def flag.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3088)       fat_proj_seen = true;
fa3cfcd0cd8f src/hotspot/share/opto/output.cpp    (Claes Redestad      2020-11-24 14:35:51 +0000 3089)       RegMaskIterator rmi(n->out_RegMask());
fa3cfcd0cd8f src/hotspot/share/opto/output.cpp    (Claes Redestad      2020-11-24 14:35:51 +0000 3090)       while (rmi.has_next()) {
fa3cfcd0cd8f src/hotspot/share/opto/output.cpp    (Claes Redestad      2020-11-24 14:35:51 +0000 3091)         OptoReg::Name kill = rmi.next();
fa3cfcd0cd8f src/hotspot/share/opto/output.cpp    (Claes Redestad      2020-11-24 14:35:51 +0000 3092)         anti_do_def(b, n, kill, is_def);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3093)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3094)     } else {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3095)       // Get DEF'd registers the normal way
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3096)       anti_do_def( b, n, _regalloc->get_reg_first(n), is_def );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3097)       anti_do_def( b, n, _regalloc->get_reg_second(n), is_def );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3098)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3099) 
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 3100)     // Kill projections on a branch should appear to occur on the
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 3101)     // branch, not afterwards, so grab the masks from the projections
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 3102)     // and process them.
efd105468659 hotspot/src/share/vm/opto/output.cpp (Jesper Wilhelmsson  2017-07-06 01:50:26 +0200 3103)     if (n->is_MachBranch() || (n->is_Mach() && n->as_Mach()->ideal_Opcode() == Op_Jump)) {
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 3104)       for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 3105)         Node* use = n->fast_out(i);
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 3106)         if (use->is_Proj()) {
fa3cfcd0cd8f src/hotspot/share/opto/output.cpp    (Claes Redestad      2020-11-24 14:35:51 +0000 3107)           RegMaskIterator rmi(use->out_RegMask());
fa3cfcd0cd8f src/hotspot/share/opto/output.cpp    (Claes Redestad      2020-11-24 14:35:51 +0000 3108)           while (rmi.has_next()) {
fa3cfcd0cd8f src/hotspot/share/opto/output.cpp    (Claes Redestad      2020-11-24 14:35:51 +0000 3109)             OptoReg::Name kill = rmi.next();
fa3cfcd0cd8f src/hotspot/share/opto/output.cpp    (Claes Redestad      2020-11-24 14:35:51 +0000 3110)             anti_do_def(b, n, kill, false);
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 3111)           }
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 3112)         }
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 3113)       }
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 3114)     }
ac99f413d79e hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-08-11 12:08:11 -0700 3115) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3116)     // Check each register used by this instruction for a following DEF/KILL
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3117)     // that must occur afterward and requires an anti-dependence edge.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3118)     for( uint j=0; j<n->req(); j++ ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3119)       Node *def = n->in(j);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3120)       if( def ) {
18329266ea16 hotspot/src/share/vm/opto/output.cpp (Vladimir Kozlov     2011-07-27 17:28:36 -0700 3121)         assert( !def->is_MachProj() || def->ideal_reg() != MachProjNode::fat_proj, "" );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3122)         anti_do_use( b, n, _regalloc->get_reg_first(def) );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3123)         anti_do_use( b, n, _regalloc->get_reg_second(def) );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3124)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3125)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3126)     // Do not allow defs of new derived values to float above GC
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3127)     // points unless the base is definitely available at the GC point.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3128) 
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 3129)     Node *m = b->get_node(i);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3130) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3131)     // Add precedence edge from following safepoint to use of derived pointer
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3132)     if( last_safept_node != end_node &&
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3133)         m != last_safept_node) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3134)       for (uint k = 1; k < m->req(); k++) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3135)         const Type *t = m->in(k)->bottom_type();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3136)         if( t->isa_oop_ptr() &&
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3137)             t->is_ptr()->offset() != 0 ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3138)           last_safept_node->add_prec( m );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3139)           break;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3140)         }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3141)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3142)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3143) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3144)     if( n->jvms() ) {           // Precedence edge from derived to safept
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3145)       // Check if last_safept_node was moved by pinch-point insertion in anti_do_use()
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 3146)       if( b->get_node(last_safept) != last_safept_node ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3147)         last_safept = b->find_node(last_safept_node);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3148)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3149)       for( uint j=last_safept; j > i; j-- ) {
be8c8aac48e6 hotspot/src/share/vm/opto/output.cpp (Niclas Adlertz      2013-08-26 12:50:23 +0200 3150)         Node *mach = b->get_node(j);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3151)         if( mach->is_Mach() && mach->as_Mach()->ideal_Opcode() == Op_AddP )
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3152)           mach->add_prec( n );
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3153)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3154)       last_safept = i;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3155)       last_safept_node = m;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3156)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3157)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3158) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3159)   if (fat_proj_seen) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3160)     // Garbage collect pinch nodes that were not consumed.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3161)     // They are usually created by a fat kill MachProj for a call.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3162)     garbage_collect_pinch_nodes();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3163)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3164) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3165) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3166) // Garbage collect pinch nodes for reuse by other blocks.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3167) //
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3168) // The block scheduler's insertion of anti-dependence
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3169) // edges creates many pinch nodes when the block contains
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3170) // 2 or more Calls.  A pinch node is used to prevent a
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3171) // combinatorial explosion of edges.  If a set of kills for a
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3172) // register is anti-dependent on a set of uses (or defs), rather
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3173) // than adding an edge in the graph between each pair of kill
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3174) // and use (or def), a pinch is inserted between them:
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3175) //
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3176) //            use1   use2  use3
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3177) //                \   |   /
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3178) //                 \  |  /
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3179) //                  pinch
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3180) //                 /  |  \
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3181) //                /   |   \
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3182) //            kill1 kill2 kill3
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3183) //
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3184) // One pinch node is created per register killed when
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3185) // the second call is encountered during a backwards pass
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3186) // over the block.  Most of these pinch nodes are never
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3187) // wired into the graph because the register is never
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3188) // used or def'ed in the block.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3189) //
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3190) void Scheduling::garbage_collect_pinch_nodes() {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3191) #ifndef PRODUCT
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 3192)   if (_cfg->C->trace_opto_output()) tty->print("Reclaimed pinch nodes:");
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 3193) #endif
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 3194)   int trace_cnt = 0;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 3195)   for (uint k = 0; k < _reg_node.Size(); k++) {
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 3196)     Node* pinch = _reg_node[k];
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 3197)     if ((pinch != NULL) && pinch->Opcode() == Op_Node &&
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 3198)         // no predecence input edges
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 3199)         (pinch->req() == pinch->len() || pinch->in(pinch->req()) == NULL) ) {
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 3200)       cleanup_pinch(pinch);
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 3201)       _pinch_free_list.push(pinch);
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 3202)       _reg_node.map(k, NULL);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3203) #ifndef PRODUCT
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 3204)       if (_cfg->C->trace_opto_output()) {
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 3205)         trace_cnt++;
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 3206)         if (trace_cnt > 40) {
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 3207)           tty->print("\n");
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 3208)           trace_cnt = 0;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3209)         }
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 3210)         tty->print(" %d", pinch->_idx);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3211)       }
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 3212) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3213)     }
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 3214)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3215) #ifndef PRODUCT
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 3216)   if (_cfg->C->trace_opto_output()) tty->print("\n");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3217) #endif
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3218) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3219) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3220) // Clean up a pinch node for reuse.
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3221) void Scheduling::cleanup_pinch( Node *pinch ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3222)   assert (pinch && pinch->Opcode() == Op_Node && pinch->req() == 1, "just checking");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3223) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3224)   for (DUIterator_Last imin, i = pinch->last_outs(imin); i >= imin; ) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3225)     Node* use = pinch->last_out(i);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3226)     uint uses_found = 0;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3227)     for (uint j = use->req(); j < use->len(); j++) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3228)       if (use->in(j) == pinch) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3229)         use->rm_prec(j);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3230)         uses_found++;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3231)       }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3232)     }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3233)     assert(uses_found > 0, "must be a precedence edge");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3234)     i -= uses_found;    // we deleted 1 or more copies of this edge
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3235)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3236)   // May have a later_def entry
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3237)   pinch->set_req(0, NULL);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3238) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3239) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3240) #ifndef PRODUCT
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3241) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3242) void Scheduling::dump_available() const {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3243)   tty->print("#Availist  ");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3244)   for (uint i = 0; i < _available.size(); i++)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3245)     tty->print(" N%d/l%d", _available[i]->_idx,_current_latency[_available[i]->_idx]);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3246)   tty->cr();
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3247) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3248) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3249) // Print Scheduling Statistics
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3250) void Scheduling::print_statistics() {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3251)   // Print the size added by nops for bundling
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3252)   tty->print("Nops added %d bytes to total of %d bytes",
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 3253)              _total_nop_size, _total_method_size);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3254)   if (_total_method_size > 0)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3255)     tty->print(", for %.2f%%",
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 3256)                ((double)_total_nop_size) / ((double) _total_method_size) * 100.0);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3257)   tty->print("\n");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3258) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3259)   // Print the number of branch shadows filled
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3260)   if (Pipeline::_branch_has_delay_slot) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3261)     tty->print("Of %d branches, %d had unconditional delay slots filled",
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 3262)                _total_branches, _total_unconditional_delays);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3263)     if (_total_branches > 0)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3264)       tty->print(", for %.2f%%",
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 3265)                  ((double)_total_unconditional_delays) / ((double)_total_branches) * 100.0);
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3266)     tty->print("\n");
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3267)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3268) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3269)   uint total_instructions = 0, total_bundles = 0;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3270) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3271)   for (uint i = 1; i <= Pipeline::_max_instrs_per_cycle; i++) {
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3272)     uint bundle_count   = _total_instructions_per_bundle[i];
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3273)     total_instructions += bundle_count * i;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3274)     total_bundles      += bundle_count;
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3275)   }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3276) 
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3277)   if (total_bundles > 0)
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3278)     tty->print("Average ILP (excluding nops) is %.2f\n",
42885307f6e5 src/hotspot/share/opto/output.cpp    (Erik Österlund      2019-10-09 12:30:06 +0000 3279)                ((double)total_instructions) / ((double)total_bundles));
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3280) }
8153779ad32d hotspot/src/share/vm/opto/output.cpp (J. Duke             2007-12-01 00:00:00 +0000 3281) #endif
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3282) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3283) //-----------------------init_scratch_buffer_blob------------------------------
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3284) // Construct a temporary BufferBlob and cache it for this compile.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3285) void PhaseOutput::init_scratch_buffer_blob(int const_size) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3286)   // If there is already a scratch buffer blob allocated and the
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3287)   // constant section is big enough, use it.  Otherwise free the
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3288)   // current and allocate a new one.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3289)   BufferBlob* blob = scratch_buffer_blob();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3290)   if ((blob != NULL) && (const_size <= _scratch_const_size)) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3291)     // Use the current blob.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3292)   } else {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3293)     if (blob != NULL) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3294)       BufferBlob::free(blob);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3295)     }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3296) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3297)     ResourceMark rm;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3298)     _scratch_const_size = const_size;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3299)     int size = C2Compiler::initial_code_buffer_size(const_size);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3300)     blob = BufferBlob::create("Compile::scratch_buffer", size);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3301)     // Record the buffer blob for next time.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3302)     set_scratch_buffer_blob(blob);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3303)     // Have we run out of code space?
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3304)     if (scratch_buffer_blob() == NULL) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3305)       // Let CompilerBroker disable further compilations.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3306)       C->record_failure("Not enough space for scratch buffer in CodeCache");
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3307)       return;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3308)     }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3309)   }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3310) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3311)   // Initialize the relocation buffers
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3312)   relocInfo* locs_buf = (relocInfo*) blob->content_end() - MAX_locs_size;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3313)   set_scratch_locs_memory(locs_buf);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3314) }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3315) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3316) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3317) //-----------------------scratch_emit_size-------------------------------------
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3318) // Helper function that computes size by emitting code
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3319) uint PhaseOutput::scratch_emit_size(const Node* n) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3320)   // Start scratch_emit_size section.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3321)   set_in_scratch_emit_size(true);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3322) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3323)   // Emit into a trash buffer and count bytes emitted.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3324)   // This is a pretty expensive way to compute a size,
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3325)   // but it works well enough if seldom used.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3326)   // All common fixed-size instructions are given a size
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3327)   // method by the AD file.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3328)   // Note that the scratch buffer blob and locs memory are
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3329)   // allocated at the beginning of the compile task, and
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3330)   // may be shared by several calls to scratch_emit_size.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3331)   // The allocation of the scratch buffer blob is particularly
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3332)   // expensive, since it has to grab the code cache lock.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3333)   BufferBlob* blob = this->scratch_buffer_blob();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3334)   assert(blob != NULL, "Initialize BufferBlob at start");
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3335)   assert(blob->size() > MAX_inst_size, "sanity");
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3336)   relocInfo* locs_buf = scratch_locs_memory();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3337)   address blob_begin = blob->content_begin();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3338)   address blob_end   = (address)locs_buf;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3339)   assert(blob->contains(blob_end), "sanity");
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3340)   CodeBuffer buf(blob_begin, blob_end - blob_begin);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3341)   buf.initialize_consts_size(_scratch_const_size);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3342)   buf.initialize_stubs_size(MAX_stubs_size);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3343)   assert(locs_buf != NULL, "sanity");
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3344)   int lsize = MAX_locs_size / 3;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3345)   buf.consts()->initialize_shared_locs(&locs_buf[lsize * 0], lsize);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3346)   buf.insts()->initialize_shared_locs( &locs_buf[lsize * 1], lsize);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3347)   buf.stubs()->initialize_shared_locs( &locs_buf[lsize * 2], lsize);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3348)   // Mark as scratch buffer.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3349)   buf.consts()->set_scratch_emit();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3350)   buf.insts()->set_scratch_emit();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3351)   buf.stubs()->set_scratch_emit();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3352) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3353)   // Do the emission.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3354) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3355)   Label fakeL; // Fake label for branch instructions.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3356)   Label*   saveL = NULL;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3357)   uint save_bnum = 0;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3358)   bool is_branch = n->is_MachBranch();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3359)   if (is_branch) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3360)     MacroAssembler masm(&buf);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3361)     masm.bind(fakeL);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3362)     n->as_MachBranch()->save_label(&saveL, &save_bnum);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3363)     n->as_MachBranch()->label_set(&fakeL, 0);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3364)   }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3365)   n->emit(buf, C->regalloc());
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3366) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3367)   // Emitting into the scratch buffer should not fail
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3368)   assert (!C->failing(), "Must not have pending failure. Reason is: %s", C->failure_reason());
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3369) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3370)   if (is_branch) // Restore label.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3371)     n->as_MachBranch()->label_set(saveL, save_bnum);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3372) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3373)   // End scratch_emit_size section.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3374)   set_in_scratch_emit_size(false);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3375) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3376)   return buf.insts_size();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3377) }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3378) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3379) void PhaseOutput::install() {
4506975561aa src/hotspot/share/opto/output.cpp    (Nils Eliasson       2020-07-03 11:46:41 +0200 3380)   if (!C->should_install_code()) {
4506975561aa src/hotspot/share/opto/output.cpp    (Nils Eliasson       2020-07-03 11:46:41 +0200 3381)     return;
4506975561aa src/hotspot/share/opto/output.cpp    (Nils Eliasson       2020-07-03 11:46:41 +0200 3382)   } else if (C->stub_function() != NULL) {
c665dba591ae src/hotspot/share/opto/output.cpp    (Claes Redestad      2021-05-06 12:57:44 +0000 3383)     install_stub(C->stub_name());
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3384)   } else {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3385)     install_code(C->method(),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3386)                  C->entry_bci(),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3387)                  CompileBroker::compiler2(),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3388)                  C->has_unsafe_access(),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3389)                  SharedRuntime::is_wide_vector(C->max_vector_size()),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3390)                  C->rtm_state());
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3391)   }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3392) }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3393) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3394) void PhaseOutput::install_code(ciMethod*         target,
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3395)                                int               entry_bci,
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3396)                                AbstractCompiler* compiler,
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3397)                                bool              has_unsafe_access,
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3398)                                bool              has_wide_vectors,
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3399)                                RTMState          rtm_state) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3400)   // Check if we want to skip execution of all compiled code.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3401)   {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3402) #ifndef PRODUCT
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3403)     if (OptoNoExecute) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3404)       C->record_method_not_compilable("+OptoNoExecute");  // Flag as failed
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3405)       return;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3406)     }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3407) #endif
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3408)     Compile::TracePhase tp("install_code", &timers[_t_registerMethod]);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3409) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3410)     if (C->is_osr_compilation()) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3411)       _code_offsets.set_value(CodeOffsets::Verified_Entry, 0);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3412)       _code_offsets.set_value(CodeOffsets::OSR_Entry, _first_block_size);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3413)     } else {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3414)       _code_offsets.set_value(CodeOffsets::Verified_Entry, _first_block_size);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3415)       _code_offsets.set_value(CodeOffsets::OSR_Entry, 0);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3416)     }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3417) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3418)     C->env()->register_method(target,
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3419)                                      entry_bci,
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3420)                                      &_code_offsets,
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3421)                                      _orig_pc_slot_offset_in_bytes,
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3422)                                      code_buffer(),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3423)                                      frame_size_in_words(),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3424)                                      oop_map_set(),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3425)                                      &_handler_table,
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3426)                                      inc_table(),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3427)                                      compiler,
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3428)                                      has_unsafe_access,
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3429)                                      SharedRuntime::is_wide_vector(C->max_vector_size()),
0fb31dbf3a2a src/hotspot/share/opto/output.cpp    (Maurizio Cimadamore 2020-11-23 11:00:38 +0000 3430)                                      C->rtm_state(),
0fb31dbf3a2a src/hotspot/share/opto/output.cpp    (Maurizio Cimadamore 2020-11-23 11:00:38 +0000 3431)                                      C->native_invokers());
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3432) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3433)     if (C->log() != NULL) { // Print code cache state into compiler log
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3434)       C->log()->code_cache_state();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3435)     }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3436)   }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3437) }
c665dba591ae src/hotspot/share/opto/output.cpp    (Claes Redestad      2021-05-06 12:57:44 +0000 3438) void PhaseOutput::install_stub(const char* stub_name) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3439)   // Entry point will be accessed using stub_entry_point();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3440)   if (code_buffer() == NULL) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3441)     Matcher::soft_match_failure();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3442)   } else {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3443)     if (PrintAssembly && (WizardMode || Verbose))
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3444)       tty->print_cr("### Stub::%s", stub_name);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3445) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3446)     if (!C->failing()) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3447)       assert(C->fixed_slots() == 0, "no fixed slots used for runtime stubs");
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3448) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3449)       // Make the NMethod
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3450)       // For now we mark the frame as never safe for profile stackwalking
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3451)       RuntimeStub *rs = RuntimeStub::new_runtime_stub(stub_name,
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3452)                                                       code_buffer(),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3453)                                                       CodeOffsets::frame_never_safe,
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3454)                                                       // _code_offsets.value(CodeOffsets::Frame_Complete),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3455)                                                       frame_size_in_words(),
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3456)                                                       oop_map_set(),
c665dba591ae src/hotspot/share/opto/output.cpp    (Claes Redestad      2021-05-06 12:57:44 +0000 3457)                                                       false);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3458)       assert(rs != NULL && rs->is_runtime_stub(), "sanity check");
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3459) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3460)       C->set_stub_entry_point(rs->entry_point());
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3461)     }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3462)   }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3463) }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3464) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3465) // Support for bundling info
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3466) Bundle* PhaseOutput::node_bundling(const Node *n) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3467)   assert(valid_bundle_info(n), "oob");
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3468)   return &_node_bundling_base[n->_idx];
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3469) }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3470) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3471) bool PhaseOutput::valid_bundle_info(const Node *n) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3472)   return (_node_bundling_limit > n->_idx);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3473) }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3474) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3475) //------------------------------frame_size_in_words-----------------------------
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3476) // frame_slots in units of words
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3477) int PhaseOutput::frame_size_in_words() const {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3478)   // shift is 0 in LP32 and 1 in LP64
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3479)   const int shift = (LogBytesPerWord - LogBytesPerInt);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3480)   int words = _frame_slots >> shift;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3481)   assert( words << shift == _frame_slots, "frame size must be properly aligned in LP64" );
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3482)   return words;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3483) }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3484) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3485) // To bang the stack of this compiled method we use the stack size
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3486) // that the interpreter would need in case of a deoptimization. This
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3487) // removes the need to bang the stack in the deoptimization blob which
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3488) // in turn simplifies stack overflow handling.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3489) int PhaseOutput::bang_size_in_bytes() const {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3490)   return MAX2(frame_size_in_bytes() + os::extra_bang_size_in_bytes(), C->interpreter_frame_size());
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3491) }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3492) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3493) //------------------------------dump_asm---------------------------------------
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3494) // Dump formatted assembly
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3495) #if defined(SUPPORT_OPTO_ASSEMBLY)
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3496) void PhaseOutput::dump_asm_on(outputStream* st, int* pcs, uint pc_limit) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3497) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3498)   int pc_digits = 3; // #chars required for pc
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3499)   int sb_chars  = 3; // #chars for "start bundle" indicator
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3500)   int tab_size  = 8;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3501)   if (pcs != NULL) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3502)     int max_pc = 0;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3503)     for (uint i = 0; i < pc_limit; i++) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3504)       max_pc = (max_pc < pcs[i]) ? pcs[i] : max_pc;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3505)     }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3506)     pc_digits  = ((max_pc < 4096) ? 3 : ((max_pc < 65536) ? 4 : ((max_pc < 65536*256) ? 6 : 8))); // #chars required for pc
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3507)   }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3508)   int prefix_len = ((pc_digits + sb_chars + tab_size - 1)/tab_size)*tab_size;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3509) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3510)   bool cut_short = false;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3511)   st->print_cr("#");
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3512)   st->print("#  ");  C->tf()->dump_on(st);  st->cr();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3513)   st->print_cr("#");
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3514) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3515)   // For all blocks
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3516)   int pc = 0x0;                 // Program counter
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3517)   char starts_bundle = ' ';
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3518)   C->regalloc()->dump_frame();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3519) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3520)   Node *n = NULL;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3521)   for (uint i = 0; i < C->cfg()->number_of_blocks(); i++) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3522)     if (VMThread::should_terminate()) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3523)       cut_short = true;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3524)       break;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3525)     }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3526)     Block* block = C->cfg()->get_block(i);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3527)     if (block->is_connector() && !Verbose) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3528)       continue;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3529)     }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3530)     n = block->head();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3531)     if ((pcs != NULL) && (n->_idx < pc_limit)) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3532)       pc = pcs[n->_idx];
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3533)       st->print("%*.*x", pc_digits, pc_digits, pc);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3534)     }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3535)     st->fill_to(prefix_len);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3536)     block->dump_head(C->cfg(), st);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3537)     if (block->is_connector()) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3538)       st->fill_to(prefix_len);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3539)       st->print_cr("# Empty connector block");
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3540)     } else if (block->num_preds() == 2 && block->pred(1)->is_CatchProj() && block->pred(1)->as_CatchProj()->_con == CatchProjNode::fall_through_index) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3541)       st->fill_to(prefix_len);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3542)       st->print_cr("# Block is sole successor of call");
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3543)     }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3544) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3545)     // For all instructions
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3546)     Node *delay = NULL;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3547)     for (uint j = 0; j < block->number_of_nodes(); j++) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3548)       if (VMThread::should_terminate()) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3549)         cut_short = true;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3550)         break;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3551)       }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3552)       n = block->get_node(j);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3553)       if (valid_bundle_info(n)) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3554)         Bundle* bundle = node_bundling(n);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3555)         if (bundle->used_in_unconditional_delay()) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3556)           delay = n;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3557)           continue;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3558)         }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3559)         if (bundle->starts_bundle()) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3560)           starts_bundle = '+';
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3561)         }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3562)       }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3563) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3564)       if (WizardMode) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3565)         n->dump();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3566)       }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3567) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3568)       if( !n->is_Region() &&    // Dont print in the Assembly
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3569)           !n->is_Phi() &&       // a few noisely useless nodes
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3570)           !n->is_Proj() &&
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3571)           !n->is_MachTemp() &&
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3572)           !n->is_SafePointScalarObject() &&
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3573)           !n->is_Catch() &&     // Would be nice to print exception table targets
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3574)           !n->is_MergeMem() &&  // Not very interesting
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3575)           !n->is_top() &&       // Debug info table constants
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3576)           !(n->is_Con() && !n->is_Mach())// Debug info table constants
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3577)           ) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3578)         if ((pcs != NULL) && (n->_idx < pc_limit)) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3579)           pc = pcs[n->_idx];
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3580)           st->print("%*.*x", pc_digits, pc_digits, pc);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3581)         } else {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3582)           st->fill_to(pc_digits);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3583)         }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3584)         st->print(" %c ", starts_bundle);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3585)         starts_bundle = ' ';
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3586)         st->fill_to(prefix_len);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3587)         n->format(C->regalloc(), st);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3588)         st->cr();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3589)       }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3590) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3591)       // If we have an instruction with a delay slot, and have seen a delay,
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3592)       // then back up and print it
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3593)       if (valid_bundle_info(n) && node_bundling(n)->use_unconditional_delay()) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3594)         // Coverity finding - Explicit null dereferenced.
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3595)         guarantee(delay != NULL, "no unconditional delay instruction");
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3596)         if (WizardMode) delay->dump();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3597) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3598)         if (node_bundling(delay)->starts_bundle())
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3599)           starts_bundle = '+';
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3600)         if ((pcs != NULL) && (n->_idx < pc_limit)) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3601)           pc = pcs[n->_idx];
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3602)           st->print("%*.*x", pc_digits, pc_digits, pc);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3603)         } else {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3604)           st->fill_to(pc_digits);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3605)         }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3606)         st->print(" %c ", starts_bundle);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3607)         starts_bundle = ' ';
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3608)         st->fill_to(prefix_len);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3609)         delay->format(C->regalloc(), st);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3610)         st->cr();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3611)         delay = NULL;
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3612)       }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3613) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3614)       // Dump the exception table as well
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3615)       if( n->is_Catch() && (Verbose || WizardMode) ) {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3616)         // Print the exception table for this offset
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3617)         _handler_table.print_subtable_for(pc);
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3618)       }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3619)       st->bol(); // Make sure we start on a new line
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3620)     }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3621)     st->cr(); // one empty line between blocks
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3622)     assert(cut_short || delay == NULL, "no unconditional delay branch");
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3623)   } // End of per-block dump
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3624) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3625)   if (cut_short)  st->print_cr("*** disassembly is cut short ***");
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3626) }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3627) #endif
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3628) 
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3629) #ifndef PRODUCT
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3630) void PhaseOutput::print_statistics() {
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3631)   Scheduling::print_statistics();
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3632) }
21cd75cb98f6 src/hotspot/share/opto/output.cpp    (Erik Österlund      2020-03-16 12:27:42 +0000 3633) #endif
